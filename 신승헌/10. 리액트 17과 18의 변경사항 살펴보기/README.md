리액트 의존적인 라이브러리를 사용하는 경우, 라이브러리가 지원하는 최소 리액트 버전에 대해 유의할 필요가 있음

(*e.g. 상태관리 라이브러리, Tanstack Query, React Hook Form, … 등 리액트 핵심 매커니즘 기반 동작*)

# 10.1 리액트 17버전 살펴보기

- 16 → 17에서는 기능 추가가 없었고, 호환성 변경을 최소화 함

## 10.1.1 리액트의 점진적 업그레이드

- 한 애플리케이션 내에 여러 버전의 리액트가 존재할 수 있음
- 예제에서는 17로 구성된 앱 내부에서 16 모듈을 Lazy 로드 하고있음
- 하지만 이는 차선책으로, 가능한 한번에 업데이트 하는게 좋음

## 10.2.1 이벤트 위임 방식의 변경

### 이벤트 추가 방식의 차이

1. 참조객체(ref)를 활용해서 추가
    1. `buttonRef.current.onClick = function click(){}`
    2. 해당 버튼의 이벤트 리스너에 click으로 핸들러가 추가됨
2. onClick에 직접 함수 추가(리액트 방식)
    1. `<button onClick={click}>버튼</button>`
    2. 해당 버튼에 noop이라는 핸들러가 추가됨
    3. 해당 핸들러는 아무런 동작도 하지 않음

### 리액트의 이벤트

- 리액트는 이벤트 핸들러를 각 DOM 요소에 부착하는것이 아니라
- 이벤트 타입 당 하나의 핸들러를 루트에 부착함

⇒ 이벤트 위임 방식

### 이벤트의 구성

1. 캡쳐: 이벤트 핸들러가 트리 최상단부터 실제 이벤트 발생 타겟 요소까지 내려가는 것
2. 타겟: 이벤트 핸들러가 노드에 도달하는 단계, 이벤트가 호출됨
3. 버블링: 이벤트가 발생한 요소에서부터 최상위 요소까지 올라감

### 이벤트 위임?

- 위와 같은 이벤트 단계의 원리를 이용해, 상위 컴포넌트에만 이벤트를 붙임
- 하위 요소의 추가/변경에 영향을 받지 않아 성능에 이점을 가짐
- 이벤트가 발생한 하위 요소(target)부터 루트까지의 모든 요소를 지나가며 fiber의 정보를 확인함
- 확인한 정보를 기반으로 루트에서 원하는 핸들러를 실행함
- 특정 하위 요소만 실행하고싶을 대에는 `stopPropagation()`

## 10.1.3 import React from ‘react’가 더이성 필요 없다: 새로운 JSX transform

- JSX변환 시 `react/jsx-runtime`을 불러오는 require 구문이 추가되었음

## 10.1.4 그 밖의 주요 변경 사항

### 이벤트 풀링 제거

### useEffect 클린업 함수의 비동기 실행

### 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 16, 17 버전은 컴포넌트 내부에서 undefined 반환 시 오류를 발생시켰음
- forwardRef나 memo 사용 시 undefined 반환에 대한 에러가 없는 문제 해결됨

## 10.1.5 정리

- 공식문서를 꼼꼼히 읽어보자~

---

# 10.2 리액트 18버전 살펴보기

## 10.2.1 새로 추가된 훅

### useId

- 컴포넌트별로 유니크한 값을 생성
- 하이드레이션 에러를 고려해서 컴포넌트 내부에 중복없는 고유한 값을 가질 수 있음
- 컴포넌트 트리의 경로(주소)를 활용해서 값을 생성해서 서버-클라이언트 간 같은 값을 가질 수 있음
- 렌더링 생명주기 내에서의 고유성

### useTransition

- UI 블로킹 없이 상태를 업데이트 할 수 있음
- 상태 업데이트의 우선순위를 낮춰서 천천히 해도 되는 일을 뒤로 미룸
- 뒤로 미룬 작업이 필요 없어지는 경우 취소하고 새로운 변경에 대한 작업을 진행할 수 있음
- 검색기능에서 글자 입력은 urgent로, 결과 리스트를 그리는 건 Transition으로 분류해서 사용자 경험을 향상할 수 있음

### useDeferredValue

- 리렌더링이 급하지 않은 부분은 지연시킬 수 있는 훅
- 디바운스와 비슷하지만, 고정된 지연시간 없이 사용할 수 있음
- props와 같이 상태업데이트 직접 관여하기 어려운 경우 사용

### useSyncExternalStore

- 18버전에 들어서면서 렌더링을 미루는 등의 최적화로 인해서 tearing 등의 동시성 이슈가 발생할 수 있게 됨
- 리액트 클로저 범위 **외부의 상태**로 인해 발생하는 동시성 이슈를 해결하기 위함
- 특정 콜백 함수를 인수로 받아 스토어에 등록하고, 외부에 있는 값이 변경될 때 마다 콜백을 호출

### useInsertionEffect

- CSS-in-js 라이브러리를 위한 훅
- DOM이 실제로 변경되기 전에 동기적으로 실행됨
- 레이아웃 계산 전에 실행될 수 있도록 해서, 자연스러운 스타일 삽입이 가능해짐

## 10.2.2 react-dom/client

클라이언트에서 리액트 트리 생성시 사용하는 API가 변경됨

### createRoot

- 기존 react-dom의 render메서드를 대체하는 메서드

### hydrateRoot

- SSR에서 하이드레이션을 위한 새로운 메서드
- 서버 API와 함께 사용

## 10.2.3 react-dom/server

### renderToPipeableStream

- 리액트 컴포넌트를 HTML로 렌더링하는 메서드
- 스트림을 지원함
- 클라이언트에서 중간에 script를 삽입하는 등 작업이 가능함
- hydrateRoot 호출까지 하면 SSR 완성~

### renderToReadableStream

- 웹 스트림(web stream)을 기반으로 작동함
- 웹 스트림을 사용하는 엣지 런타임 환경에서 사용되는 메서드
- 쓸일이 있을까..?

## 10.2.4 자동 배치

- 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법

…

## 10.2.5 더욱 엄격해진 엄격 모드

### 리액트의 엄격모드

- 리액트에서 제공하는 컴포넌트 중 하나
- 컴포넌트 형태로 선언해서 쓸 수 있음
- 개발 모드에서만 작동함

### 주요 작업

- 안전하지 않은 생명주기 사용에 대한 경고
- 문자열 ref 사용 금지
- findDomNode에 대한 경고 (권장되지 않는 메서드)
- 구버전 Context API 사용 시 경고
- 부작용(side-effects) 검사: 아래 내용들을 이중으로 호출함
    - 클래스형 컴포넌트 - constructor, render, shouldComponentUpdate, getDerivedStateFromProps
    - 함수형 컴포넌트 - body, useState/useMemo/useReducer에 전달되는 함수

### 리액트 18에서 추가된 엄격 모드

- 컴포넌트가 처음 마운트될 때, 자동으로 모든 컴포넌트를 마운트 해제하고, 두번째 마운트에서 이전 상태를 복원함
- 추후 마운트 해제된 상태에서도 내부 상태값을 유지하는 기능을 제공하기 위함
- 엄격모드에서 useEffect가 두 번 작동한것 처럼 보이는 이유이기도 함

## 10.2.6 Suspense 기능 강화

- Suspense는 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능
- Lazy를 통해 불러오는 컴포넌트를 대신해 보여줄 fallback을 prop으로 받을 수 있음
- 초기 렌더링 속도 향상에 도움이 됨

## 10.2.7 IE 지원 중단에 따른 폴리필 필요

- Promise, Symbol, Object.assign
- 위 세 기능을 지원하지 않는 브라우저에서 서비스 하려면 폴리필 추가가 필수적이다

## 10.2.8 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 undefined 반환 가능, null과 동일하게 처리
- `<Suspense fallback={undefined}>`도 null과 동일하게 처리
- renderToNodeStream 지원 중단, renderToPipeableStream 사용 권장

## 10.2.9 정리

- 18버전의 핵심은 **동시성 렌더링**
- 복잡해진 렌더링에도 일관된 UI를 위한 기능