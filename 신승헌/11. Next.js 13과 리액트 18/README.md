Next.js 13, 대격변 패치

- 리액트 18의 채택
- 레이아웃 지원
- Turbopack 출시

---

# 11.1 app 디렉터리의 등장

## 11.1.1 라우팅

### app router

- 폴더명까지만 주소로 반환됨

### layout.{js | jsx | ts | tsx}

- 라우팅 폴더 내에 layout을 둘 수 있음
- 하위 폴더(주소)에 모두 영향
- 기존에 _document에서 하던 작업을 layout 또는 루트 layout에서 할 수 있음
- 예약어로 다른 용도로는 사용할 수 없음
- children props 필수

### page.{js | jsx | ts | tsx}

- params, searchParams를 props로 받음

### error.{js | jsx | ts | tsx}

- 공통 에러 컴포넌트
- **props**
    - `error: Error` 에러 정보를 담은 객체
    - `reset: () => void` 에러 바운더리 초기화 로직
- 에러바운더리는 클라이언트에서만 작동하기 때문에 에러 컴포넌트도 클라이언트 컴포넌트여야 함
- 같은 뎁스의 layout에서 발생한 에러는 처리하지 못함, 필요한 경우 상위에 error 컴포넌트 추가
- 또는 app의 루트에 `global-error.js` 를 추가해 사용할 수 있음

### not-found.{js | jsx | ts | tsx}

### loading.{js | jsx | ts | tsx}

### route.{js | ts}

- 파일 내부에 메서드명을 예약어로 선언해두면, HTTP 요청에 맞게 해당 메서드를 호출
- 꼭 api 폴더 내부가 아니더라도 파일을 배치할 수 있음. 다만, page파일과는 공존할 수 없음
- params
    - `request`: NextRequest 객체
    - `context`: params만을 가지고 있는 객체, 동적 라우팅 파라미터 객체가 포함됨

---

# 11.2 리액트 서버 컴포넌트

- SSR과는 완전히 다른 개념

## 11.2.1 기존 리액트 컴포넌트와 SSR의 한계(+ 서버컴포넌트의 이점)

- 대부분 리액트가 클라이언트를 중심으로 실행되기 때문에 발생하는 문제
- 서버/클라이언트 모두의 장점을 위해 서버컴포넌트를 사용

### 1. 일정 번들 사이즈 최적화 제한

- 브라우저 환경에서 타사 라이브러리 이용은 불가피하고, 이는 사용자 기기의 부담으로 이어짐
- 서버 컴포넌트에서는 라이브러리를 서버에서만 실행 후 결과물만 클라이언트에 제공할 수 있음

### 2. 백엔드 리소스 직접 접근 불가

- 클라이언트에서는 REST API와 같이 접근을 위한 절차를 따로 마련해야 함
- DB나 파일시스템에 직접 접근이 가능하게 되면, 성능 관점에서도 이점을 가질 수 있음

### 3. 자동 코드 분할 불가

- 코드분할이란 코드를 작은 단위로 나누어 필요할 때만 동적으로 지연로딩하는 기법
- 리액트에서는 lazy를 사용해 구현함
- **lazy 지연로딩의 단점 몇가지**
    - lazy를 일일히 써주어야 하는 관리 소요 발생
    - 지연 로딩하는 컴포넌트 사이즈가 작다면, 서버에 요청하고 응답을 기다리는 시간(RTT)이 더 길 수 있음
    - 조건식이 까다롭거나, 여러 컴포넌트를 동시에 지연로딩 하면 메인스레드 병목이 발생할 수 있음
    - 워터폴 현상 - 데이터 흐름을 직렬화, 사용자 요청에 따라 컴포넌트를 지연로딩 하면서 실제 대기시간이 길어질 수 있음
- 서버에서 코드 분할을 자동으로 수행 해주면 개발자가 따로 신경쓰지 않아도 되고, 코드분할의 이점을 최대로 활용할 수 있음
    
    > **서버에서 코드분할을 자동으로 수행한다는게 무슨 뜻일까🤔**
    제가 이해한 대로 정리해보았는데 만약 잘못된 부분이 있다면… 언제든 반박해주세요!
    > 
    - 빌드 타임에 서버/클라이언트 전용 번들로 코드분할
    - 서버컴포넌트 실행 중 Client Component(”use client”)를 만나면, 해당 부분은 실행하거나 결과물에 포함하지 않음
    - 대신 어떤 컴포넌트가 들어갈 자리인지 **참조 정보**만 결과물(RSC payload)에 기록함
    - 결과물이 브라우저로 전달되었을 때 참조를 따라 필요한 클라이언트 번들을 동적 로드
    - 명시적인 lazy 없이 빌드 타임에 “use client” 경계를 기준으로 분할되고,
    서버 런타임에 분할된 결과를 선택적으로 전달하기 때문에
    ⇒ 자동 코드 분할 이라고 함(것 같음)

### 4. 연쇄적으로 발생하는 요청 대응 어려움

- 컴포넌트의 렌더링 결과로 하위 컴포넌트를 렌더링 하는 경우 하위 컴포넌트들의 요청이 지연될 수 있음
- 상위 컴포넌트의 렌더링이 끝나기 전에는 하위 컴포넌트의 렌더링이나 서버 요청이 지연됨
- 서버에서 수행하는 경우 클라이언트-서버 간 요청으로 발생하는 지연을 줄일 수 있음
- 서버에서 필요에 따라 백엔드리소스에 직접 접근하고, 지속적인 데이터 로딩으로 효율적인 렌더링이 가능해짐

### 5. 추상화 비용 증가

- 리액트는 자바스크립트를 기반으로 함수/클래스를 사용해 다양한 작업을 수행할 수 있게(추상화 하여) 제공함
- 추상화가 복잡해질수록 코드 양이 증가하고, 런타임에 오버헤드가 발생함
- 복잡한 추상화에 따른 결과물을 서버에서 연산하면 클라이언트에 부하를 줄일 수 있음

## 11.2.2 서버컴포넌트란?

- 하나의 언어, 하나의 프레임워크, 하나의 API를 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링 할 수 있는 기법
- 일부는 서버에서, 일부는 클라이언트에서 렌더링
- 클라이언트 컴포넌트는 서버컴포넌트를 import 할 수 없음

### 서버 컴포넌트 특징

- 요청이 오는 순간 딱 한번 실행됨
- 상태를 가질 수 없음
- 렌더링 생명주기 사용불가
- DOM API, window, document 등 브라우저 관련 기능 사용 불가
- 컴포넌트 자체가 async 가능함, 서버 리소스에 async/await 비동기로 접근이 가능함

### 클라이언트 컴포넌트 특징

- 서버 컴포넌트를 불러(import)오거나, 서버 전용 훅/유틸을 사용할 수 없음
- 그러나 children으로 클라이언트 컴포넌트의 자식으로 서버컴포넌트를 갖는 구조는 가능함
    - 서버에서 이미 만들어진 트리를 삽입만 해서 보여주면 되기 때문에 가능함
    - import 해서 쓰는건 안됨!

```tsx
// (Server Component)
import ClientWrapper from './ClientWrapper';

export default function Page() {
  return (
    <ClientWrapper>
      <ServerContent />
    </ClientWrapper>
  );
}
```

### 공용 컴포넌트 특징

- 서버/클라이언트 모두에서 사용할 수 있음

## 11.2.3 SSR과 RSC의 차이

- SSR은 정적 HTML을 빠르게 내려주는데에 초점
    - JS코드 다운로드, 파싱, 실행(Hydration) 등에 비용이 발생함
- RSC로 렌더링 가능한 컴포넌트 렌더링 후, 클라이언트 컴포넌트는 SSR로 빠르게 로드가 가능함
- 상호보완하는 개념

## 11.2.4 RSC는 어떻게 작동하는가?

### 1. 서버가 렌더링 요청을 받음

- RSC를 사용하는 페이지는 항상 서버에서 시작됨
- 루트에 있는 컴포넌트는 항상 서버 컴포넌트

### 2. 서버는 요청에 따라 컴포넌트를 JSON으로 Serialize(직렬화)

- 클라이언트 컴포넌트 부분은 placeholder 형식으로 비워둠

### 3. 브라우저가 리액트 컴포넌트 트리 구성

- JSON 구문을 파싱해서 트리를 구성하고 컴포넌트를 생성함
- 클라이언트 컴포넌트의 경우 렌더링을 진행하고, 서버컴포넌트의 경우 트리에 반영함
- 완성된 트리를 DOM에 커밋

### 서버 컴포넌트 작동 방식의 특징

- 스트리밍 형태로 정보를 전달함
    - 클라이언트가 줄 단위로 JSON을 읽고 빠르게 렌더링 할 수 있음
- 각 컴포넌트들이 별도로 번들링 되어있음
    - 필요에 따라 지연로딩이나 따로 전송받는 등 작업이 가능함
- 결과물이 JSON 형태로 전달됨
    - 단순히 HTML을 그리는 작업 이상의 일(JS 파싱, 실행 등)을 효율적으로 할 수 있음

### 알아두기

- 위와 같은 특징으로 인해, 서버컴포넌트에서 클라이언트 컴포넌트로 props를 전달할 때 반드시 직렬화 가능한 데이터를 넘겨야 함
- getServerSideProps로 페이지에 props를 넘겨줄 때
- 직렬화 할 수 없는 class나 Date 등은 서버에서 클라이언트로 넘겨줄 수 없음

---

# 11.3 Next.js에서의 리액트 서버 컴포넌트

## 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- app 라우터에서 `getServerSideProps`, `getStaticProps`, `getInitialProps` 가 삭제됨
- 모든 데이터 요청은 `fetch`를 기반으로 실행

## 11.3.2 정적 렌더링과 동적 렌더링

- Next.js 13에서는 정적 라우팅을 위해 빌드타임에 미리 렌더링 후 캐싱해서 재사용할 수 있게 함
    - 캐싱하지 않는 경우 미리 빌드해두지 않고, 요청마다 fetch이후 렌더링을 수행함
    
    ```tsx
    
    async function getData() {
    	const res = await fetch(
    		`https://api.com`,
    		// 캐싱하지 않는다고 선언
    		{ cache: "no-cache" },
    		);
    	const data = await res.json();
    	return data;
    }
    ```
    
- 동적 라우팅은 요청마다 컴포넌트를 렌더링하도록 변경됨
- Next.js에서 제공하는 `next/headers`나 `next/cookies` 같은 헤더, 쿠키 정보를 불러오면 정적렌더링 대상에서 제외됨
- generateStaticParams를 사용하면 getStaticPaths를 흉내낼 수 있음
    - 동적 라우팅 중에 특정 주소를 캐싱하고싶은 경우

## 11.3.3 캐시와 mutating, revalidating

- Next.js는 fetch의 기본 동작을 설정할 수 있는 `{next: {revalidate?: number | false}`옵션을 제공함
- 단순히 변수 선언만으로 revalidate 할 수 있음
    
    ```tsx
    // page.tsx
    export const revalidate = 60;
    // 하위에 있는 모든 라우팅에서 60초 마다 페이지를 갱신(새로 렌더링)함
    ```
    

### 캐시 갱신과정

1. 최초 요청에는 캐시해둔 데이터 사용
2. 초기 요청을 revalidate 값 만큼 유지
3. 시간이 지나도 기존 캐시데이터를 사용
4. 백그라운드에서 데이터 로드
5. 4번 성공 시 캐시데이터 갱신, 실패 시 과거 데이터 사용

☝️ `router.refresh();`메서드로 새로고침 없이 루트부터 데이터를 갱신할 수 있음

이 작업은 브라우저나 리액트 state에 영향을 미치지 않음

## 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- 기존 SSR은 “렌더링 → 클라이언트 전송 → 하이드레이션”까지 순차적인 작업이 모두 완료되어야 페이지가 완성됨
- 스트리밍을 활용하면 데이터가 로드되는 컴포넌트를 먼저 보여줄 수 있음
- TTFB(Time To First Byte), FCP(Full Contentful Paint) 지표를 개선할 수 있음
- 사용자가 기다리는 시간을 줄일 수 있고, 로딩 중 임을 명확하게 보여줄 수 있음
- suspense를 활용해 페이지단위 또는 컴포넌트, 섹션 단위로 로딩상태를 표시할 수 있음

---

# 11.4 터보팩의 등장

- 웹팩 대비 최대 700배, Vite 대비 최대 10배 빠름
- 러스트 기반
- 이제는 Next.js의 기본 번들러가 되었어요(2026년 1월 20일 현재)

---

# 11.5 서버 액션

- Next.js 13.4.0에서 서버액션이라는 새로운 기능이 등장
- API 생성 없이도 함수 수준에서 서버에 직접 접근이 가능함

## 11.5.1 form의 action

- form에 action props로 form데이터를 처리할 URI를 넘겨줄 수 있음
- 이벤트는 클라이언트에서 발생되지만, 실제 함수 수행은 서버에서 실행됨

### 서버액션을 활용한 데이터 스트리밍

1. 서버 컴포넌트에서 데이터를 로드해 렌더링
2. 서버 액션으로 서버 리소스 업데이트
3. `next/cache`의 `revalidatePaths` 로 해당 주소의 캐시데이터 갱신
- 최초 페이지 로딩 → 서버에 데이터 수정 요청 → 수정된 결과 업데이트
- 위 과정이 새로고침 없이 데이터 스트리밍으로 이루어짐

### Server mutatation

서버측에서 데이터를 변경하고, 결과에 따라 클라이언트 UI를 업데이트 하는 과정을 말함

주로 서버액션으로 실행됨

- server mutation으로 실행할 수 있는 함수
    1. redirect: 특정 주소로 리다이렉트
    2. revalidatePath: 해당 주소의 캐시를 즉시 업데이트
    3. revalidateTag: 특정 tag를 가진 fetch 요청 초기화

## 11.5.2 input의 submit과 image의 formAction

- input의 type이 “submit” 또는 “image”인 경우에도 props로 서버액션 추가가 가능함

## 11.5.3 startTransition과의 연동

- useTransition의 startTransition에서도 서버액션을 활용할 수 있음
- page단위의 loading.tsx를 사용하지 않아도 됨
- 데이터에 의존하지 않고, 컴포넌트 단위의 로딩처리도 가능해짐

## 11.5.4 server mutation이 없는 작업

- server mutation이 필요하면 반드시(아님) 서버 액션을 useTransition과 함께 사용해야 함
    - 반드시는 아니고 Next.js와 React 팀이 **강력**하게 권장하고 있음
    - 사용자 경험과 렌더링 최적화 측면
        1. revalidation 깜빡임 방지
        2. isPending을 통한 즉각적인 피드백
        3. `<form>` 외부에서도 서버액션을 호출하기 위해
            1. startTransition으로 form 외부에서 서버액션을 호출하면
            2. form의 상태를 formStatus가 아니라 isPending으로 관리할 수 있음
- 별도 server mutation이 없다면 바로 이벤트 핸들러에 넣어도 됨

## 11.5.5 서버 액션 사용 시 주의할 점

- 클라이언트 컴포넌트(”use client”)에서 정의할 수 없음
- 클라이언트 컴포넌트에서 서버액션을 쓰는 경우 “use server”로 서버액션만 모여있는 파일을 import 해서 사용해야 함
- props 형태로 서버액션을 클라이언틑 컴포넌트에 넘겨줄 수 있음
- 서버 자원은 반드시 파일단위 분리!

---

# 11.6 그 밖의 변화

---

# 11.7 Next.js 코드 맛보기

## 11.7.1 getServerSideProps와 비슷한 서버사이드 렌더링 구현해 보기

- 서버컴포넌트에서 fetch를 수행하고, 별다른 cache 옵션을 설정하지 않으면 유사하게 작동함

## 11.7.2 getStaticProps와 비슷한 정적 페이지 렌더링 구현해 보기

- generateStaticParams와 fetch를 사용해서 구현할 수 있음
- 따로 cache 옵션을 설정하지 않으면, 가능한 모든 cache 값을 사용하도록 설정하는 것과 같음
- revalidate 전역 변수 선언으로 일정 기간마다 정적페이지를 갱신시킬수도 있음

## 11.7.3 로딩, 스트리밍, 서스펜스

- Next.js의 스트리밍과 리액트의 서스펜스를 활용해 렌더링중임을 나타낼 수 있음
- Suspense로 감싸진 컴포넌트는 스트리밍으로 응답을 점진적으로 받아 렌더링 함

---

# 11.8 정리 및 주의사항

- 엄청나게 많은 기능이 추가되었음
- [공식문서](https://nextjs.org/docs)를 읽어보자