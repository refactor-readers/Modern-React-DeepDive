### 리액트 밖에서 일어나는 이슈를 디버깅하기 위한 도구

- 자바스크립트 메모리, 네트워크, 소스코드, 실제 HTML/CSS등
- 리액트가 아닌 일반적인 웹애플리케이션 환경을 디버깅

---

# 7.1 크롬 개발자도구

- 시크릿 모드에서 사용하는게 좋다 ⇒ 브라우저 확장프로그램 간섭 방지
- 순수하게 웹페이지와 관련된 정보만 확인할 수 있음

---

# 7.2 요소 탭

- 현재 웹페이지 구성하는 HTML, CSS 정보 확인
- 좌측에 HTML 트리 / 우측에 선택한 요소와 관련된 정보

## 7.2.1 요소 화면

- HTML을 개발자도구에서 직접 수정해볼 수 있음
- 특정 요소에 “중단위치 > 옵션” 설정을 통한 디버깅
    - 중단 설정 관련 작업이 일어날 때 마다 브라우저 렌더링을 중단
    - 해당 요소 변경을 일으킨 소스코드를 보여줌

| 옵션 이름 | 의미 | 언제 쓰나? |
| --- | --- | --- |
| Subtree modifications | 이 태그의 자식(하위) 요소가 추가/삭제/변경될 때 멈춤 | 리스트에 새 항목이 갑자기 추가될 때 범인 찾기 |
| Attribute modifications | 이 태그의 속성(class, id, style 등)이 바뀔 때 멈춤 | 버튼 색깔(class)이 멋대로 바뀔 때 |
| Node removal | 이 태그 자체가 삭제될 때 멈춤 | 화면에서 갑자기 컴포넌트가 사라질 때 |

## 7.2.2 요소 정보

### Style

- 스타일 정보

### Computed

- 해당 요소의 크기, 패딩, 보더, 마진 등 CSS가 적용된 결과값
- 결과물을 확인할 수 있음

### Layout

- CSS 그리드나 레이아웃 관련 정보

### Event Listeners

- 현재 요소에 연결된 이벤트리스너 확인
- Ancesters 토글로 상위요소를 제외하고, 해당 요소에 직접 연결된 이벤트만 볼 수도 있음

### DOM Breakpoints

- 요소화면에서 설정한 중단위치(중단점)이 있는지 알려줌

### Properties

- 현재 요소가 가진 **모든** 속성값(`.attributes`)

### Accessibility

- 웹 접근성과 관련된 정보

---

# 7.3 소스 탭

- 웹 애플리케이션을 로드하기 위해 실행/참조된 모든 파일을 확인할 수 있음
- Javascript, CSS, HTML, font 등 다양함
- 프로덕션 모드에서는 파일이 모두 압축되어 있음
- 개발모드에서는 다양한 파일을 소스코드까지 모두 확인할 수 있음
- 스코프, 호출스택 등 자바스크립트가 실행되고 있는 구조도 확인할 수 있음

### Watch

- 특정 변수를 지정해서 해당 변수의 정보를 확인할 수 있음
- 디버깅 시점에 특정 변수의 값을 알고싶을 때 사용

### Breakpoints

- 중단점을 전부 확인할 수 있음
- 현제 웹페이지 전체에 걸쳐서 소스탭에서 설정한 중단점 모두 확인 가능

### Scope

- 현재 중단점에서의 스코프를 의미함
- 로컬/클로저/전역 스코프 등을 확인할 수 있음

### Call Stack

- 현재 중단점의 콜스택을 확인할 수 있음
- 자바스크립트 코드가 실행되며 생성되는 실행 컨텍스트를 직접 볼 수 있음

### Global Listeners

- 전역 스코프에 추가된 리스너 목록

### …

---

# 7.4 네트워크 탭

- 웹페이지 접속 이후 발생하는 모든 네트워크 관련 작동이 기록됨
- HTTP 요청, 웹소켓 등 외부와 통신하는 정보를 확인할 수 있음
- 잘못된 useEffect 사용으로 인한 중복요청 등 코드 상 문제들도 파악이 가능함
- 스크린샷 캡쳐 기능으로 네트워크 요청 흐름에 따른 페이지 로딩상태도 확인 가능함

### 주요 확인사항

1. 불필요한 요청, 중복요청
2. 리소스 크기
3. 리소스 로드 속도, 병목
4. 리소스 다운로드 우선순위

---

# 7.5 메모리 탭

- 현재 웹페이지가 차지하고 있는 메모리 관련 정보
- 가장 어렵고 까다로운 부분
- 애플리케이션에서 발생하는 메모리 누수, 속도저하, 프리징 현상을 확인할 수 있는 유용한 도구

### 힙 스냅샷

- 현재 메모리 상황을 사진 찍듯이 기록할 수 있음

### 타임라인 할당 계측

- 시간의 흐름에 따라 메모리의 변화를 확인할 수 있음
- 로딩되는 과정이나 페이지 내 상호작용에 따른 메모리 변화를 확인할 때 주로 사용

### 할당 샘플링

- 메모리를 차지하고 있는 자바스크립트 함수를 볼 수 있음

## 7.5.1 자바스크립트 인스턴스 VM 선택

- Select JavaScript VM instance 항목을 살펴보면 현재 실행중인 자바스크립트 VM 인스턴스를 확인할 수 있음
- 디버깅 하고싶은 VM 환경을 선택하면 됨
- 실제 해당 페이지가 자바스크립트 힙을 얼마나 점유하고 있는지 볼 수 있고
    - 크기가 곧 브라우저에 부담이기 때문에, 불필요하게 늘어나는지 확인해야 함

## 7.5.2 힙 스냅샷

- 현재 페이지의 메모리 상태를 확인해볼 수 있는 프로파일 도구
- 스냅샷 촬영 시점을 기준으로 메모리 현황을 보여줌

### 힙 스냅샷 활용하기

- 원인이 되는 함수 실행 전/후로 스냅샷을 기록하고
- 각 스냅샷 사이에 할당된 객체를 확인
- 어떤 변수가 메모리를 크게 잡아먹고 있는지 확인할 수 있음
- 또한 handleClick같은 원인이 된 함수 등도 확인이 가능함
- 해당 객체 우클릭 후 “전역변수로 저장”하면 해당 변수의 값을 확인할 수도 있음
- 또한 스냅샷을 활용해 useMemo, useCallback과 같은 의존성이 있는 값들이 렌더링 사이에 메모이제이션 되는지도 확인할 수 있음
- 스냅샷에서 함수를 명확히 확인하려면, 기명함수를 쓰는게 좋음

### 얕은 크기 vs 유지된 크기

**얕은 크기**는 객체 자체가 보유하는 메모리의 크기를 나타냄

**유지된 크기**는 해당 객체 자체뿐만 아니라 모든 자식 객체들 크기까지 더한 값

- 메모리 누수를 찾을 때는 얕은크기는 작으나 유지된크기가 큰 객체를 찾아야 함
- 객체 자체의 크기 < 유지된크기
- 해당 객체가 복잡한 참조관계를 가지고 있다는 뜻
- 이런 객체가 메모리에 오래 남아있다면, 메모리 누수가 발생할 수 있음

## 7.5.3 타임라인 할당 계측

- 타임라인 할당 계측은 시간의 흐름에 따라 메모리 변화를 확인할 수 있는 기능
- 검색 범위를 좁혀서 원하는 특정 기간도 확인해볼 수 있음
- 기간동안 모든 변화를 기록하기 때문에 브라우저에 부담이 될 수 있음

## 7.5.4 할당 샘플링

- 시간흐름에 따른 메모리 점유를 확인할 수 있음
    - 할당 계측과 비슷하지만 다름
- 자바스크립트 실행 스택별로 분석 가능
- 해당 분석을 함수 단위로 진행함

### 특징

- 프로파일링 시 브라우저에 주는 부담을 최소화 할 수 있음
- 메모리 누수 지점 파악이 어려운 경우 활용할 수 있음
- 오랜 기간 메모리 누수가 의심되어 장기간 프로파일링이 필요한 경우 활용하면 좋음

---

# 7.6 Next.js 환경 디버깅하기

- 성능 저하는 사용자 책임도 있다(?) *아주* *조금 인정합니다.*
- SSR 환경에서 메모리 누수는 어떻게 디버깅 해야할까?

## 7.6.1 Next.js 프로젝트를 디버그 모드로 실행하기

```tsx
"dev": NODE 0PTIONS='-inspect' next dev
```

- 위 명령어로 디버그 모드를 실행할 수 있음
- 크롬에서 Open dedicated DevTools for Node를 클릭

### 7.6.2 Next.js 서버에 트래픽 유입시키기 feat. ab

- 오픈소스 도구인 `ab`를 활용해서 모의 트래픽을 시뮬레이션 해볼 수 있음([공식문서](https://httpd.apache.org/docs/))
- `b -k -c 50 -n 10000 " 'http://l27.0.0.1:3000/"` 
*한번에 50개의 요청을 10000회 시도*
- `ab` 를 사용하면 요청 수행 뿐만 아니라 결과에 대한 정보도 확인할 수 있음

## 7.6.3 Next.js의 메모리 누수 지점 확인하기

### 누수 지점 확인하기

```tsx
import type { GetServerSidePropsContext, NextPage } from "next";

// 전역 변수 선언
const users = [];

function Home({ currentDateTime }: { currentDateTime: number }) {
	return <>{currentDateTinle)</>
};

export const getServerSideProps = (ctx: GetServersidePropsContext) => {
	const currentDateTime = new Date().getTime();
	
	// getServerSideProps 실행 시 마다 전역 객체에 user를 push
	users.push({
		user: `user-${Math.round(Math.random() + 100000)}`,
		currentDateTime,
	})
	
	return {
		props: {
			currentDateTime,
		},
	}
}
export default Home
```

1. 디버그 모드로 실행 후, 메모리 탭 확인
2. 새로고침 등으로 getServerSideProps가 실행되면, users 전역 객체에 지속적으로 추가됨

---

# 7.7 정리

> 크롬 개발자 도구에는 웹페이지의 모든 정보가 담겨져 있다.
크롬 개발자 도구를 더 적극 활용해보자!👏
>