## 리액트의 탄생 배경

### 페이스북의 프론트엔드

**애플의 강력한 앱 규제에 반발해 시작된 페이스북의 “스파르탄 프로젝트”**

> 애플리케이션을 HTML5를 사용한 하이브리드 앱으로 제작하여 WebKit에서 작동시키려는 시도
> 네이티브의 안정성과 속도에 밀려 실패, HTML5 기반 하이브리드 앱 상용화의 시작점이 되었고
> 이와 같은 시도를 통해 웹의 중요성이 더욱 부각됨.

**브라우저의 발전**

> 웹소켓, 캔버스, SVG 등으로 사용자에게 다양한 인터렉션을 보여줄 수 있었고
> Ajax의 등장으로 클라이언트 사이드에서도 데이터 로딩이 가능케 되는 등
> 이에 따라 자바스크립트 코드가 점차 복잡해지기 시작함.

**리액트의 시초**

> 실험적으로 사용되었던 BoltJS를 함수형 지향 버전으로 개선한 FBolt를 시작으로,
> 기존의 방식에서 벗어나 데이터 변경이 발생할 때 단순히 UI를 초기화 하고 다시 렌더링하는 아이디어가 제안됨

### 과거의 문제점

> 리액트 이전(jQuery, 초기 Angular 등)에는 데이터가 바뀌면 **DOM의 어떤 부분을 수정해야 할지** 일일이 코드로 작성해야 했음

> 애플리케이션이 커질수록 데이터(Model)와 화면(View)의 동기화를 추적하기가 너무 복잡해짐
> (양방향 바인딩의 복잡성, 나쁜건 아님)

### 리액트의 접근

- **"데이터가 바뀌면 그냥 싹 다 지우고 새로 그리면 어떨까?"** 라는 아이디어에서 출발.
- **Virtual DOM**
  - 실제로 브라우저 DOM을 모두 지우고 새로 그리는 건 성능이 너무 떨어짐.
  - 메모리에 가상의 DOM을 두고, 변경 전후를 **비교(Diffing)**한 뒤 **바뀐 부분**만 실제 DOM에 적용(Reconciliation)
  - 성능과 개발 편의성을 모두 챙길수 있었음.

---

## 관심사 분리의 변화

### 파일 별 → 컴포넌트 별

- **기존 (파일 별 관심사)**
  HTML, CSS, JS를 파일별로 나누는 것이 '관심사의 분리'라고 여겨짐.
  하지만 실제로는 버튼 하나를 수정하려면 3개의 파일에서 관련된 부분을 찾고, 수정해야 했음.
- **리액트 (컴포넌트 별 관심사)**
  "관심사"의 정의를 재정립.
  **'기능(Feature)' 단위 분리’ ⇒** JSX를 통해 구조, 스타일, 로직을 하나의 **컴포넌트**라는 단위로 묶어 응집도를 높이고 결합도를 낮출 수 있었음.

---

## 프로토타입 (Prototype)

- 자바스크립트는 클래스 기반 언어(Java, C# 등)가 아니라 **프로토타입 기반 언어**.
- ES6에서 `class` 문법이 나왔지만, 이는 사실 내부적으로 프로토타입을 사용하기 편하게 만든 '문법적 설탕(Syntactic Sugar)’.
- 리액트의 초기 `Class Component`도 결국 `React.Component`의 프로토타입을 상속받아 동작하는 원리.

---

## 클로저 (Closure)와 메모리

> 선언되었을 때 함수 동작이 끝나도, 내부 변수는 어디에 저장될까?

### 렉시컬 환경(Lexical Environment)

- 함수가 실행되면 그 함수만의 '환경'이 생성됨.
- 클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
- 내부 함수가 외부 함수의 환경(변수 등)을 참조하고 있을 때, 외부 함수의 실행이 끝나도 그 환경이 사라지지 않고 유지됨.

### 자바스크립트 엔진의 **힙(Heap) 메모리**

- 보통 함수가 종료되면 가비지 컬렉터(GC)가 메모리를 청소함.
- 하지만 클로저로 인해 "이 변수는 나중에 내부 함수가 쓸 거야"라고 참조가 남아있으면, GC는 이를 삭제하지 않고 힙 메모리에 남겨둠.
- 리액트의 `useState`가 상태를 유지하는 비결이 바로 이 클로저.

---

## 자바스크립트가 싱글 스레드인 이유

- 자바스크립트는 원래 브라우저에서 DOM을 조작하기 위해 탄생했음.

### 멀티 스레드의 위험성 (동시성 이슈)

- 만약 멀티 스레드라면, A 스레드는 "DOM에 텍스트 추가", B 스레드는 "DOM 삭제"를 동시에 시도할 수 있음
- 이러면 **동기화 문제(Deadlock, Race Condition)** 가 발생하여 브라우저가 매우 복잡해지고 버그가 발생하기 쉬워짐

> 복잡성을 피하고 안정적으로 DOM을 제어하기 위해 싱글 스레드(Run-to-completion) 모델을 채택.
> 대신 비동기 작업은 **이벤트 루프**를 통해 처리.

---

## 태스크 큐는 사실 큐(Queue)가 아니라 Set?

- 보통 "큐(First In, First Out)"라고 부르지만, ECMAScript/HTML 스펙상으로는 **Set(집합)**에 가까움

### 왜냐면..

- 브라우저는 단순히 먼저 들어온 것을 실행하는 것이 아니라,
  성능 최적화나 우선순위에 따라 **"실행 가능한 태스크 중 가장 오래된 것"** 을 선택하여 가져오기 때문
- 개념적으로는 순서대로 처리된다고 이해해도 무방.

## 렌더링과 마이크로 / 매크로 태스크 큐

> `Call Stack 비움` → `Microtask Queue 처리(Promise 등)` → **`렌더링(Render)`** → `Macrotask Queue 처리(setTimeout 등)` …

### UX

- 무거운 작업이 Call Stack을 오래 점유하거나 Microtask를 계속 발생시키면, 브라우저는 렌더링을 할 틈이 없어서 화면이 버벅거림.
- 따라서 무거운 계산은 `setTimeout` 등을 이용해 매크로 태스크로 미루거나.
- `Web Worker`를 사용하여 메인 스레드를 양보해야 사용자에게 부드러운 UX를 제공할 수 있음.

---

## 배열과 객체 구조분해 할당의 차이 (useState)

### 배열 구조분해

> **순서**가 중요함. 변수 이름은 내 마음대로 지을 수 있음.

```js
const [state, setState] = useState(0);
const [count, setCount] = useState(0);
```

- `useState`는 사용하는 곳마다 변수명이 다름.
- 만약 객체로 반환했다면 매번 이름을 바꿔주어야함 (`const { state: count, setState: setCount } = ...`).

### 객체 구조분해

- **키 이름**이 중요.
- 순서는 상관없음.
- 데이터의 속성이 명확할 때 사용.

```js
const { name, age } = user;
```

### 구조분해 할당 기본값 (undefined vs null)

- 기본값은 변수가 **엄격하게 `undefined`일 때만** 적용
- `null`은 "값이 없다"는 것을 명시적으로 할당한 **값**으로 취급되므로 기본값이 적용되지 않음.

```js
const [a = 10] = [undefined]; // a는 10
const [b = 10] = [null]; // b는 null
```

---

## 덕 타이핑과 Object.keys의 반환 타입

### 덕 타이핑(Duck Typing)

- "오리처럼 걷고 오리처럼 꽥꽥대면 오리다." 즉, 객체의 구체적인 타입보다는 **어떤 속성과 메서드를 가지고 있느냐**에 따라 타입을 규정하는 방식. **(자바스크립트의 동적 성질)**

### TypeScript에서 `Object.keys`가 `string[]`인 이유

- TypeScript는 **구조적 타이핑(Structural Typing)**을 따름
- `Type A = { a: string, b: number }`라고 정의해도,
  런타임에는 `{ a: "hi", b: 1, c: "hidden" }` 같은 객체가 들어올 수 있음 **(잉여 속성 허용)**.
- 따라서 `Object.keys`를 실행했을 때, 타입 정의에 있는 키(`a`, `b`) 외에 다른 키(`c`)가 나올 수 있으므로, 안전하게 `keyof A`가 아닌 `string[]`으로 강제하는 것!

---

끝!
