# 1.1 동등비교

- react를 잘 활용하기 위해서 동등 비교의 개념을 확실하게 이해하고 있어야 한다.
  - props의 동등 비교로 Component가 렌더링할 지를 판단하고 리렌더링 함
  - Virtual DOM과 실제 DOM의 비교
  - 변수나 함수의 메모이제이션

## 1.1.1 데이터 타입

### 원시 타입

> 객체가 아닌 모든 타입

- undefined
- boolean
- null
- number
- string
- symbol
- bigint

#### 💡 원시 타입을 다룰 때 신경써야 하는 점

- null의 `typeof null`은 object이다.
- string은 변경 불가한 값이다.
  - `string[0] = "a"` 형식으로 수정 불가
- truthy한 값과 falsy한 값을 구별해야한다.

  - falsy한 값 : `undefined`, `null`, `0`, `NaN`, `''`, `""`, ``
  - truthy한 값: falsy한 값을 제외한 모든 값 (`{}`, `[]`도 truthy한 값이다)

    > 조건부 렌더링으로 빈 배열일 때 처리를 해주고 싶다면 신경써줘야한다.

    ```tsx
    const Components = () => {
      const { data } = useGoodsList();

      // 빈 객체가 내려와도 truthy한 값이라 먼저 return될 수 있다.
      if (!data) {
        return <div>불러올 데이터가 없습니다.</div>;
      }

      return (
        <div>
          {data.map((item) => (
            <div>{item.name}</div>
          ))}
        </div>
      );
    };
    ```

### 객체

> 배열, 함수, 정규식, 클래스 등

#### 💡 객체 타입을 다룰 때 신경써야 하는 점

- 참조를 저장한다고 해서 참조 타입으로 불리는데, 내용이 같은 두 객체를 동등 비교해도 참조가 다르기 때문에 `false`가 나온다.

## 1.1.2 값을 저장하는 방식의 차이

1. 원시 타입
   - 불변 형태의 값 자체를 저장
     - 할당 시점에 메모리 영역을 차지하고 저장됨
2. 객체 타입
   - 프로퍼티 삭제, 추가, 수정이 가능하게 하기 위해 변경 가능한 형태로 저장된다.
     - 복사할 때도 참조를 전달

### 💡 Deep Dive

객체 타입의 프로퍼티를 삭제, 추가, 수정이 가능하도록 변경 가능한 형태로 저장된다는 것은 무슨 의미일까?

## 1.1.3 자바스크립트의 또 다른 비교 공식 `Object.is`

### `==` vs `Object.is`

1. `==`

   비교하는 대상의 타입 캐스팅을 진행한 후, 값을 비교한다.

   ```ts
   const one = "1";
   const numberOne = 1;

   const isEqual = one == numberOne; // true
   ```

2. `Object.is`
   비교하는 대상의 타입이 다르면 무조건 `false`를 반환한다.
   - 그렇다면 `===`와 같은 것이 아닌가?
     - ❌ No !
       - `Object.is`는 `NaN`, `-0`과 `+0`의 비교는 동등 비교보다 정확하게 해주지만, 완전히 같은 데이터를 가진 객체의 비교는 `false`를 반환한다.

## 1.1.4 리액트에서의 동등 비교

리액트에서의 동등 비교는 `==` 이나 `===`와 동일하게 동작하는 것이 아닌 `Object.is`의 비교이다.

- 이를 이용해서 shallowEqual를 의존성 비교 등과 같은 동등 비교가 필요한 여러 상황에서 사용한다.

### 고려사항

`Object.is`는 ES6에서 제공하는 기능이라 Polyfill를 ...

### ✏️ 그렇다면 왜 리액트는 얕은 비교를 수행하는 것일까? 깊은 복사로 전부 비교하면 정확하고 좋지 않은가?

- **얕은 비교로도 대체로 충분** : 일반적으로 JSX로 전달되는 props 변경으로 일어나는 렌더링은 얕은 비교로 충분하다.
- **성능저하 방지** : props로 전달되는 객체가 얼마나 깊을 지 알 수 없기 때문에 모든 경우에 깊은 복사를 위해 재귀적으로 비교했다면 성능에 악영향을 미칠 것이다.

- 해당 예제처럼 props가 깊어지는 경우 memo가 변경된 게 없더라도 메모이제이션된 객체를 반환하지 못하는 문제가 발생한다.

- `DeeperComponent`의 상위 컴포넌트인 `App`에서 버튼을 눌러 강제로 렌더링을 일으킬 경우, `shallowEqual`을 사용하는 `Component` 함수는 리렌더링을 방지해주었지만 `DeeperComponent`는 `memo`가 제대로 작동하지 않았다.

## 1.1.5 정리

//

<br />

# 1.2 함수

## 1.2.1 함수란 무엇인가?

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고 이를 블록으로 감싸서 실행 단위로 만들어놓은 것

- 컴포넌트를 생성하는 함수도 이 같은 방식과 같다

## 1.2.2 함수를 정의하는 4가지 방법

### 함수 선언문

표현식이 아닌 문으로, 무언갈 산출하는 구문

```js
function add() {
  return; //...
}
```

💡**고려해야하는 점**

- 자바스크립트 엔진은 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하기도 한다. <br />
  => 함수 선언문으로 선언되었지만 표현식으로 해석될 수도 있다는 뜻

### 함수 표현식

```js
const add = function () {
  return; //...
};
```

- 함수는 일급 객체이기 때문에 당연히 변수에 할당이 가능하다.
- 함수는 무명 함수로 선언하는데, 이는 코드 가독성 및 혼란을 방지하기 위해서이다.
  - 이름을 붙여 선언해도 해당 함수명의 스코프는 해당 함수 내부에서만 유효하기 때문에 사용하지 않는다. (외부에서 호출 불가)

💡 **일급 객체란?**

- 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
  - 다른 함수의 매개변수로 주입될 수 있는가? ✅
  - 반환값으로 사용될 수 있는가? ✅
  - 변수에 할당이 가능한가? ✅

#### 함수 표현식과 선언 식의 차이점 (호이스팅의 차이)

> ❓호이스팅이란? : 선언문이 코드의 맨 앞단에 있는 것처럼 동작하는 것

**1. 함수 선언문의 호이스팅**

- 실행 전에 미리 메모리에 등록됨 <br />
  => 선언문 이전에 호출을 해도 **정상적으로 호출**된다.

**2. 함수 표현식의 호이스팅**

- 변수도 호이스팅이 일어나지만 변수는 var이면 undefined로 초기화 됨(호이스팅 시점에) <br />
  => 공간만 만듬 **(호출 시 에러)**
- 순서 : `런타임 이전에 undefined로 초기화` > `할당문이 실행되는 시점, 런타임에 함수 할당`

### Function 생성자

- 가독성도 나쁘고, 클로저도 생성하지 않는 등 일반적인 함수와 다르게 동작하여 권장되지 않는 방식이다.

### 화살표 함수

```js
const add = () => {
  return; //...
};
```

#### 화살표 함수의 특징

**1. `constructor`**

- `constructor`를 사용할 수 없어 생성자 함수로 사용할 수 없다.

**2. arguments 객체 존재 X**
**3. this 바인딩**

> ❓this란? : 내가 속한 객체나 생성할 인스턴스 (렉시컬 환경 X, 어떻게 호출되냐에 따라 결정됨,)

- 일반 함수로 호출되면 전역 객체가 `this`가 된다.
- 화살표 함수는 상위 스코프의 `this`를 그대로 따라간다.

## 1.2.3 다양한 함수 살펴보기

### IIFE (Immediately Invoked Function Expression) 즉시 실행 함수

단 한 번 호출되고 다시는 호출될 수 없는 함수

- 글로벌 스코프를 오염시키지 않고 독립적인 함수로 스코프를 관리할 수 있는 장점
- 코드를 읽는 입장에서도 다른 곳에서 재사용되지 않는 함수라는 것을 명시적으로 의미할 수 있어 리팩토링에 도움이 된다.

### HOF (Higher Order Function) 고차함수

함수가 일급 객체라는 사실을 이용하여 함수를 인수로 받거나 결과로 새로운 함수를 반환 시키는 함수

- 대표적인 고차함수는 `map` 이다.

## 1.2.4 함수를 만들 때 주의해야할 상황

### 함수의 부수효과를 최대한 억제하라.

#### 순수함수

동일한 인수를 주입했을 때 언제나 동일한 결과가 반환되는 함수 <br />
=> 예측 가능하고 안정적

<br/>

모든 함수를 순수 함수로 만드는 것은 불가능하지만 부수 효과를 발생시키는 함수를 최대한 줄인다면

- 함수의 역할을 줄이고
- 버그를 줄이며
- 컴포넌트의 안정성을 높일 수 있다.

### 함수를 가능한 한 작게 만들어라

함수의 역할에 따라서 몇 줄 이하로 만들어라 라고 규정할 수는 없지만, 일반적으로 `max-lines-per-function`의 규칙에서는 50줄 이하로 되어 있다.

- 하나의 함수에서 너무 많은 일을 하는 것을 옳지 않다.

### 누구나 이해할 수 있는 이름을 붙여라

- `Terser`를 이용하면 한글 네이밍으로 코드를 작성해도 정상적으로 컴파일 된다.
  > ❓ 맹글링이란? : 자바스크립트 코드를 컴파일러가 이해할 수 있는 수준으로 단순화해주는 것
- useEffect나 useCallback에 넘겨주는 콜백 함수에 이름을 붙이는 것도 가독성에 도움이 된다.
  ```tsx
  useEffect(function apiRequest()=>{
    //..
  },[])
  ```

## 1.3 클래스

16.8 이전 버전에서는 모든 Component가 클래스 컴포넌트였다.

### 1.3.1 클래스란 무엇인가?

특정한 객체를 만들기 위한 템플릿

- 자바스크립트에서 이를 활용하면 객체를 만드는데 필요한 데이터나 이를 조작하는 코드를 추상화하여 객체 생성을 더욱 편리하게 할 수 있다. (재사용성 증가)

#### constructor

- 객체 생성에 사용
- 하나의 클래스에는 하나의 `constructor`만 존재
- 불필요하다면 생략 가능

#### property

- 인스턴스 생성할 때 내부에 정의할 수 있는 속성값
- `#`을 붙여서 정의하면 `private` 프로퍼티가 된다.
  > 과거에 지원하지 않을 때는 `_` prefix로 네이밍하여 표현

#### getter과 setter

- 값을 가져올 때는 get ...
- 값을 할당할 때는 set ...

#### 인스턴스 메서드

- 클래스 내부에서 선언한 메서드
- 실제 자바스크립트의 prototype에 선언되어 프로토타입 메서드라고 불리기도 함

**💡 prototype에 선언된다는 것의 의미**

- 새로 생성한 `prototype`, `getPrototypeof()`, `__proto__`(지양)로 조회했을 때 프로토타입 체인에 추가되는 것 (생성자에서 프로토타입 체이닝을 통해 사용 가능해지는 것)

#### 정적 메서드

- 클래스 인스턴스가 아닌 이름으로 호출하는 메서드로, 클래스 자신을 가리켜서 this로 사용할 수 없다.
- 그래서 리액트 클래스형 컴포넌트 생명주기 메서드인 `static getPerivedStateFromProps(props,state)` 에서는 this.state에 접근할 수 없다.

정적 메서드의 장점

- 인스턴스를 생성하지 않고 사용할 수 있다. <br />
  => 생성하지 않고 사용이 가능하다는 것은 전역 유틸을 정적 메서드로 사용할 수 있다는 것

#### 상속

- 기존 클래스를 상속 받아서 자식 클래스에서 확장할 수 있는 것

### 1.3.2 클래스와 함수의 관계

- ES6 이전에서는 프로토타입을 활용해 클래스의 작동 방식을 동일하게 구현할 수 있었다.

# 1.4 클로저

## 1.4.1 클로저의 정의

**"함수와 함수가 선언된 렉시컬 스코프의 조합**

## 1.4.2 변수의 유효범위, 스코프

### 전역 스코프

- 전역 레벨에서 선언되었을 때 가지는 스코프

### 함수 스코프

- `{}` 블록이 스코프 범위를 결정하지 않음
- 자바스크립트는 이를 따르고 있음

## 1.4.3 클로저의 활용

리액트에서 useState의 구현이 가능한 이유는 자바스크립트가 함수 스코프를 가지기 때문이다.

## 1.4.4 주의할 점

var의 i로 선언한 반복문은 전역 스코프를 가져서 외부에서 변경할 수 있음 (함수 레벨 스코프가 아님)

- let은 기본적으로 블록레벨 스코프
- 클로저를 사용하는 데에는 비용이 든다 : 선언적 환경을 기억해야 해서, 꼭 필요한 작업만 남겨두는 것이 아니라면 메모리를 불필요하게 잡아먹게 된다.

# 1.5 이벤트 루프와 비동기 통신의 이해

자바스크립트는 기본적으로 싱글 스레드에서 작동한다.

- 기본적으로 한 번에 하나의 작업만 동기 방식으로 처리할 수 있다.

**1. 동기 (synchronous)**

- 직렬 방식으로 처리
- 요청 시작 이후 반드시 응답을 받아야 다른 작업이 가능하다.

**2. 비동기 (asynchronous)**

- 병렬 방식으로 처리
- 여러 작업이 동기에 실행 가능하다.

## 1.5.1 싱글 스레드 자바스크립트

과거에는 프로그램을 실행하는 단위가 오직 프로세스 뿐이었지만, 점차 앱에서 요구되는 작업이 복잡해지면서 스레드(thread)라는 더 작은 작업 단위가 등장했다.

- 프로세스는 여러 개의 스레드를 가질 수 있고, 하나의 프로세스에 해당하는 스레드들은 하나의 메모리를 공유한다.

### 왜 자바스크립트는 싱글 스레드인걸까?

- 멀티 스레드는 하나의 자원을 여러 스레드에서 접근할 수 있기 때문에 동시성 제어를 위한 처리를 해줘야하고, 하나의 스레드에서 문제가 생기면 같은 자원을 공유하는 다른 스레드에서도 연쇄적으로 문제가 발생할 수 있다.
- 자바스크립트가 개발될 당시의 기대 역할은 HTML을 그리고 보조하는 수단에 그쳤었다.
- 멀티 스레드의 단점과, DOM 조작을 보조하는 역할에 있어 동시성 제어가 올바르게 되지 않을 때 브라우저의 DOM 표시에 이상이 생길 수도 있기 때문에 그런 것이다.

## 1.5.2 이벤트루프란?

자바스크립트 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치이다.

### call stack(호출스택)과 이벤트루프

#### call stack

수행해야 할 코드나 함수를 순차적으로 담아두는 스택

- call stack이 비어있는지 아닌지 여부를 확인하는 것이 이벤트 루프의 역할이다. 이때 이를 확인하는 것은 이벤트루프만의 단일 스레드에서 수행된다.
  - call stack 내부에 수행해야할 작업이 있는지 확인
  - 수행해야할게 있으면 자바스크립트 엔진을 이용해 실행시킨다. <br />
    => 그리고 이 두 작업은 동기적으로 일어나기 때문에 동시에 실행될 수 없다. (단일 스레드라서)

#### taskQueue (태스크큐)

실행해야 할 태스크의 집합

- 이벤트루프는 이러한 태스크 큐를 한 개 이상 가지고 있고, 자료구조는 큐가 아니라 `set`이다.

**❓ 왜 set구조로 되어 있을까?** <br/>

- 선택된 큐 중에서 가장 오래된 걸 꺼내와야하기 때문에

### 태스크 큐로 들어간 비동기코드는 어디서 실행되는 걸까?

자바스크립트의 메인 스레드가 아닌, 태스크큐가 할당하는 별도의 스레드에서 실행된다.

- 별도의 스레드에서 태스크큐에 작업을 할당해 처리하는 건 브라우저나 Node.js의 역할이다.

자바스크립트의 코드 실행은 싱글 스레드에서 이뤄지지만, 외부 Web API 등은 모두 자바스크립트 코드 외부에서 실행되고, 콜백이 태스크 큐로 들어간다.

- 이벤트 루프는 call stack이 비고, 콜백이 실행 가능한 상태가 되면 이것을 꺼내서 수행하는 역할을 한다.

## 1.5.3 태스크 큐와 마이크로 태스크 큐

이벤트루프는 하나의 마이크로 태스크 큐를 갖는데, 기존의 태스크 큐와는 다른 태스크를 처리한다.

> 예) `Promise`

- 마이크로 태스크 큐는 태스크 큐보다 우선권을 가지고, 마이크로 태스크큐가 빌 때까지 태스크 큐는 대기한다.

### 렌더링 시점은 언제일까?

마이크로 태스크 큐 > 렌더링 > 태스크 큐

- 각 마이크로 태스크 큐가 끝날 때마다 렌더링 된다.
- 브라우저에 다음 리페인트 전에 콜백 함수 호출을 가능하게 하는 `requestAnimationFrame`으로 확인이 가능하다.
- 브라우저 렌더링은 마이크로와 태스크 큐 사이에서 일어난다.

# 1.6 리액트에서 자주 사용하는 자바스크립트 문법

ECMAScript에서 매년 새로운 문법이 등장하는데, 각 브라우저에서 새로 나온 문법을 지원하는 지 여부를 확인해야한다.

- 물론 `바벨`을 사용하면 ES5 기준으로 더 높은 버전의 자바스크립트 코드를 트랜스파일 해주기는 하지만, ES5 기준으로 트랜스파일된 코드 파악도 할 줄 알아야한다.

## 1.6.1 구조분해할당

## 1.6.2 전개 구문

## 1.6.3 객체 초기자 (object shorthand assignment)

## 1.6.4 Array 프로토타입 메서드: map, filter, reduce, forEach

### forEach 사용 시 주의점

- 반환값이 없이 콜백을 수행만 함
- 에러를 던지거나 프로세스를 종료하지 않는 이상 멈출 수 없음
  > break이나 return도 안됨

## 1.6.5 삼항 조건 연산자

# 1.7 선택이 아닌 필수, 타입스크립트

## 1.7.1 타입스크립트란?

```md
TypeScript is JavaScript with syntax for types.
```

자바스크립트 문법에 타입을 가미한 것 (자바스크립트의 슈퍼셋이다)

- 런타임에서만 에러를 확인할 수 있는 자바스크립트의 단점을 보완할 수 있음
  - 정적으로 빌드(트랜스파일) 타임에 수행할 수 있게 해줌

## 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

### any 대신 unknown을 사용하자

- any를 사용하는 것은 타입스크립트의 이점을 사용하지 않는 것이다.
- unknown을 사용한 뒤 type narrowing을 통해 타입을 좁혀 사용하자.

### 타입 가드를 적극 활용하자

#### instanceof와 typeof

지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자이고, typeof는 특정 요소에 대해 자료형을 확인하는 데 사용된다.

#### in

in은 property in object로 사용되는데, 주로 어떤 객체에 키가 존재하는지 확인하는 용도로 사용된다.

- 인자로 두 개의 객체가 들어올 수 있을 때 특정 객체에만 있는 프로퍼티 값을 사용하여 타입을 좁힐 수 있다.

#### 제네릭

단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구이다.

- 제네릭을 사용하면 타입만 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선얺 ㅐ간결하게 작성할 수 있다.
- 리액트에서는 useState에서 제네릭을 사용해 타입을 명확하게 해줄 수 있다.
  - 기본값을 사용하면 기본값으로 state의 타입이 추론된다.

#### 인덱스 시그니처

객체의 키를 정의하는 방식

```ts
type Hello = {
  [key: string]: string; // string이라는 너무 넓은 범위의 타입
};

type Hi = Record<"hello" | "hi", string>;

const hello: Hi = {
  hello: "hello",
  hi: "hi",
};

// 또는
type Hello = { [key in "hello" | "hi"]: string };
```

- 하지만 이렇게 정의해뒀음에도 다음과 같은 이슈를 마주할 수 있다.

```ts
Object.keys(hello).map((key) => {
  // Element implicitly has an 'any' type because expression of type 'string'
  // can't be used to index type 'Hello'
  // No index signature with a parameter of type 'string' was found on type 'Hello'
  const value = hello[key];
  return value;
});
```

- `Object.keys(hello)`가 반환하는 타입이 `string[]`인 걸 볼 수 있는데, 이를 해결하기 위해서는 아래와 같은 방법으로 시도해볼 수 있다.

```ts
// Object.keys(hello)를 as로 타입을 단언하는 방법
(Object.keys(hello) as Array<keyof Hello>).map((key) => {
  const value = hello[key];
  return value;
});

// 타입 가드 함수를 만드는 방법
function keyOf<T extends Object>(obj: T): Array<keyof T> {
  return Array.from(Object.keys(obj)) as Array<keyof T>;
}

keysOf(hello).map((key) => {
  const value = hello[key];
  return value;
});

// 가져온 key를 단언하는 방법
Object.keys(hello).map((key) => {
  const value = hello[key as keyof Hello];
  return value;
});
```

### 왜 Object.keys는 string으로 강제되어 있을까?

- 자바스크립트의 특징과, 이를 구현하기 위한 타입스크립트의 구조적 타이핑의 특징 때문이다.
- 자바스크립트는 다른 언어에 비해 객체가 열려있는 구조로 만들어져 있으므로 덕 타이핑(duck typing)으로 객체를 비교해야하는 특징이 있다.
  > ❓덕 타이핑이란? 객체의 타입이 클래스 상속, 인터페이스 구현 등으로 결정 되는 것이 아니로 어떤 객체가 필요한 변수와 메서드만 지니고 있다면 그냥 해당 타입에 속하도록 인정해 주는 것을 의미한다.
  > 어떤 것이 오리처럼 걷고, 소리를 내면 그것은 무엇이든 오리라고 부를 수 있는 것
  - 이런 특징 때문에 타입스크립트 인터페이스 소개란에는 다음과 같은 문장이 등장한다.
  ```md
  One of TypeScript's core principles is that type checking focuses on the shape that values have. This is sometimes called "duck typing" or "structural subtyping"
  타입스크립트의 핵심 원칙 중 하나는 타입 검사가 값의 형태에 초점을 맞춘다는 것입니다. 이를 "덕 타이핑" 또는 "구조적 서브타이핑"이라고 부르기도 합니다.
  ```
  - 타입 체크를 할 때 그 값이 가진 형태에 집중한다.
- 이를 보완할 수 있는 `Exact`라는 새로운 타입의 요청이 있지만, 아직까지 받아들여지지는 않고 있다.

## 1.7.3 타입스크립트 전환 가이드

### tsconfig.json 먼저 작성하기

- 환경을 조성하는 것이 우선이다.

```json
{
  "compilerOptions": {
    "outDir": "./dist",
    "allowJs": true,
    "target": "es5"
  },
  "includes": ["./src/**/*"]
}
```

### JSDoc과 @ts-check를 활용해 점진적으로 전환하기

- 상단에 @ts-check를 선언하고, JSDoc을 활용해 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인한다.

### 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기

### 파일 단위로 조금씩 전환하기
