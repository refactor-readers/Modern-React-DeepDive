프론트엔드에서 접할 수 있는 보안 이슈에 대해서 주로 다룬다고 합니다.

# 14.1 리액트에서 발생하는 크로스 사이트 스크립팅(XSS)

웹사이트 개발자가 아닌 제3자가 웹사이트에 악성 스크립트를 삽입해 실행할 수 있는 취약점을 의미한다.

- 일반적으로 게시판과 같이 사용자가 입력을 할 수 있고, 이 입력을 다른 사용자에게 보여줄 수 있는 경우 발생한다.

## 14.1.1 dangerouslySetlnnerHTML prop

특정 브라우저 DOM의 innerHTML을 특정한 내용으로 교체할 수 있는 방법이다.

- 인수로 받은 `_html` 키가 있는 객체를 무조건 DOM에 그대로 표시함

# 14.1.2 useRef를 활용한 직접 삽입

- useRef를 사용하면 직접 DOM에 접근할 수 있으므로 이 DOM에 앞서 비슷한 방식으로 innerHTML에 보안 취약점이 있는 스크립트를 삽입하면 동일한 문제가 발생한다.

## 14.1.3 리액트에서 XSS 문제를 피하는 방법

제 3자가 삽입할 수 있는 HTML을 안전한 HTML 코드로 한 번 치환하는 것
=> 새니타이즈(sanitize) 또는 이스케이프(escape)라고 하는함

- npm에 있는 라이브러리를 사용할 수 있음
  - DOMpurity
  - sanitize-html
  - js-xss

보여줄 때 뿐만 아니라 저장할 때도 이 같은 과정을 거치는 것이 안전하다.

- 저장될 때 이스케이프하면 그 뒤로 보여줄 때마다 일일히 이스케이프 과정을 거치지 않아도 훨씬 효율적이기 때문
- 이러한 치환 과정은 되도록 서버에서 수행하는 것이 좋다.

#### 쿼리스트링에 있는 내용 그대로 실행하거나 보여주는 경우에도 보안 취약점이 발생할 수 있다.

#### 리액트의 JSX 데이터 바인딩

리액트는 기본적으로 XSS를 방어하기 위해 이스케이프 작업이 존재하기 때문에 dangerouslySetInnerHTML이라는 속성이 별도로 존재한다.

# 14.2 getServerSideProps와 서버 컴포넌트를 주의하자

서버에는 일반 사용자에게 노출되면 안 되는 정보들이 담겨 있기 때문에 클라이언트, 즉 브라우저에 정보를 내려줄 때는 조심해야 한다.

- getServerSideProps가 반환하는 props 값은 모두 사용자의 HTML에 기록되고, 전역변수로 등록되어 스크립트로 충분히 접근할 수 있는 보안 위협에 노출되는 값이 됨

- 성능상의 불이익 : getServerSideProps에서 처리할 수 있는 리다이렉트가 클라이언트에서 실행되면 손해를 봄

=> 고로 getServerSideProps가 반환하는 값 또는 서버 컴포넌트가 클라이언트 컴포넌트에 반환하는 props는 반드시 필요한 값으로만 철저하게 제한되어야 함

# 14.3 <a> 태그의 값에 적절한 제한을 둬야 한다

- 피싱 사이트로 이동하는 것을 막기 위해 가능하면 origin도 확인하는 것이 좋다.

# 14.4 HTTP 보안 헤더 설정하기

HTTP 보안 헤더란 브라우저가 렌더링하는 내용과 관련된 보안 취약점을 미연에 방지하기 위해 브라우저와 함께 작동하는 헤더를 의미

- 웹사이트 보안에 가장 기초적인 부분으로, HTTP 보안 헤더만 효율적으로 사용할 수 있어도 많은 보안 취약점을 방지할 수 있음

## 14.4.1 Strict-Transport-Security

모든 사이트가 HTTPS를 통해 접근해야 하며, 만약 HTTP로 접근하는 경우 이러한 모든 시도는 HTTPS로 변경되게 한다는 헤더

`Strict-Transport-Security: max-age=<expire-time>; includeSubDomains`

- expire-time 설정은 브라우저가 기억해야 하는 시간을 의미, 초 단위로 기록
  - 이 기간 내에는 HTTP로 사용자가 요청한다 하더라도 브라우저는 이 시간을 기억하고 있다가 자동으로 HTTPS로 요청한게 됨
  - 이 시간이 경과하면 HTTP로 로드를 시도한 다음에 응답에 따라 HTTPS로 이동하는 등의 작업을 수행
  - 이 시간이 0으로 되어 있으면 즉시 만료되고 바로 HTTPS로 요청하게 됨
  - 일반적으로 1년 단위로 허용하지만, `https://hstspreload.org/`에 따르면 권장값은 2년

## 14.4.2 X-XSS-Protection

비표준 기술, 사파리와 구형 브라우저에서만 제공되는 기능

- XSS 취약점이 발견되면 페이지 로딩을 중단

## 14.4.3 X-Frame-Options

페이지를 frame, iframe, embed, object 내부에서 렌더링을 허용할지를 나타낼 수 있음

예시
네이버와 비슷한 주소를 가진 페이지가 있고, 이 페이지에서 네이버를 iframe으로 렌더링한다고 가정할 때, 사용자는 이 페이지를 진짜 네이버로 오해할 수 있고, 공격자는 이를 활용해 사용자의 개인정보를 탈취할 수 있음

그래서 해당 헤더는 외부에서 자신의 페이지를 위와 같은 방식으로 삽입되는 것을 막아주는 헤더

## 14.4.4 Permissions-Policy

웹사이트에서 사용할 수 있는 기능과 사용할 수 없는 기능을 명시적으로 선언하는 헤

- 개발자는 다양한 브라우저의 기능이나 API를 선택적으로 활성화하거나 필요에 따라서는 비활성화할 수도 있음
  - 카메라나 GPS와 같이 브라우저에서 제공하는 기능

## 14.4.5 X-Content-Type-Options

#### MIME (Multipurpose Internet Mail Extensions)

- Content-type의 값으로 사용 됨
- 원래는 메일을 전송할 때 사용하던 인코딩 방식이지만, Content-type에서 대표적으로 사용되고 있음

- Content-type: text/css 헤더가 없는 파일은 브라우저가 임의로 CSS로 사용할 수 없고
- Content-type: text/javaScript나 Content-type: application/javascript 헤더가 없는 파일은 자바스크립트로 사용할 수 없음

## 14.4.6 Referrer-Policy

HTTP 요청에는 Referrer라는 헤더가 존재하는데, 이 헤더에는 현재 요청을 보낸 페이지의 주소가 나타남

- 이때 이 헤더에서 사용할 수 있는 데이터를 나타냄
  - Refer라는 오타가 이미 표준으로 사용되버렸다지요 (ㄹㅈㄷ 휴먼 에러)

## 14.4.7 Content-Security-Policy

콘텐츠 보안 정책은 XSS 공격이나 데이터 삽입 공격과 같은 다양한 보안 위협을 막기 위해 설계됨

### \*-src

font-src, img-src, script-src 등 다양한 src를 제어할 수 있는 지시문

### from-action

폼 양식으로 제출할 수 있는 URL을 제한할 수 있음

# 14.4.8 보안 헤더 설정하기

## Next.js

HTTP 경로별로 보안 헤더를 적용할 수 있음 (`next.config.js`에서 설정)

## NGINX

정적인 파일을 제공하는 NGINX의 경우 다음과 같이 경로별로 add_header 지시자를 사용해 원하는 응답 헤더를 추가할 수 있음

# 14.4.9 보안 헤더 확인하기

보안 헤더의 현황을 알려주는 `https://securityheaders.com/`을 방문하는 것

# 14.5 취약점이 있는 패키지의 사용을 피하자

- github의 Dependabot이 발견한 취약점은 빠르게 업데이트 조치하는 것이 좋

# 14.6 OWASP Top 10

Open Worldwide (Web) Application Security Project 라는 오픈소스 웹 애플리케이션 보안 프로젝트를 의미

- 주로 웹에서 발생할 수 있는 정보 노출, 악성 스크립트, 보안 취약점 등을 연구하며, 주기적으로 10대 웹 애플리케이션 취약점을 공개하는데 이를 OWASP Top10이라고 함
- 매번 보안 취약점의 빈도에 따라 순위를 매기며, 이 순위는 발표가 있을 때마다 조금씩 바뀜

# 14.7 정리

버그가 없는 완벽한 소프트웨어는 없다.

- 하지만 꾸준히 보안 취약점이 없는지 확인하며 안전한 서비스를 제공해야 사용자에게 신뢰받는 서비스를 만들 수 있을 것
