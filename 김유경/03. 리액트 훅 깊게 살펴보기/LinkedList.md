#### 딥다이브!

앞서 훅의 호출 순서가 보장되어야 하는 이유를 퀴즈로 내봤는데용, 해당 부분의 동작을 좀 더 자세히 알아보다보니, Linked List를 기용하고 있는 부분이 많아 좀 더 딥다이브 해보고 싶어져 내용을 가져와봤습니다.

간단하게 useState를 구현한 구조를 봤을 때는 `global.states`를 배열로 설명하고 있는데요, 실제 구현에서는 Linked List를 통해서 훅의 순서를 보장하고 있다고 합니다.

왜 리액트는 Linked List를 선택한 건지 좀 더 자세하게 알아볼까요???

### 리액트가 memoizedState에 배열 대신 연결 리스트(Linked List) 구조를 선택한 이유

#### 구조 변경의 효율성

React는 훅 이외에도 파이버 트리 전체를 연결 리스트 형태로 관리합니다. 연결 리스트는 중간에 요소를 추가하거나 제거할 때, 배열 처럼 뒤의 모든 요소를 밀거나 당길 필요 없이 앞뒤 노드의 **포인터**만 수정하면 되기 때문에 매우 효율적입니다.

=> 시간 복잡도 O(1) 를 가진다고 할 수 있지요

해당 효율성은

- 컴포넌트가 마운트(추가)되거나, 언마운트(제거)되어 파이버 트리의 구조가 동적으로 변경될 때 큰 성능 이점을 제공합니다 !

#### 복잡한 데이터 저장 능력

Hooks Linked List의 각 노드(Hook Object)는 단순히 상태 값만 저장하는 배열 슬롯이 아닙니다. 이 노드는 Hook의 모든 메타데이터를 담는 컨테이너 역할을 합니다.

### ❓ Q. 그렇다면 Hook의 관점에서, 이 노드에 현재 상태값 (예: 'A', 0) 외에 리액트가 비동기적으로 상태를 업데이트하기 위해 반드시 저장해야 하는 핵심 정보는 무엇일까요??

한 번 생각해보시라 공백을 넣어보도록 하겠습니다.

> 힌트 : `setState`를 호출하면 이 요청은 바로 반영되지 않고, 어딘가에 대기하고 있어야 합니다.

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

### 💡 정답

#### Update Queue (업데이트 큐)

정답은 Hook 객체가 현재 상태 값(`memoizedState`)외에 반드시 저장해야 하는 핵심 정보는 바로 **업데이트 큐** 입니다.

책에 나오는 useState의 약식 구현코드는 setState가 호출되면 `global.states` 배열의 값을 "즉시" 변경했지만, 실제 React Fiber에서는 다음과 같은 과정을 거칩니다

1. 사용자가 setValue(newValue)를 호출합니다
2. React는 새로운 상태 값이나 업데이트 함수(예: prev => prev + 1)를 담은 업데이트 객체를 만들고, 이 객체를 해당 Hook 노드에 있는 연결 리스트 형태의 큐에 추가합니다.
3. React는 이 큐에 업데이트가 있음을 확인하고, 스케줄러에게 "이 컴포넌트를 다시 렌더링해야 한다" 라고 알린다 (즉시 실행 X 비동기 예약)
   => 여기서 React Fiber의 역할인 스케줄링이 드러나죠?

이 update Queue 덕분에 여러 번의 setState 호출이 하나의 렌더링 사이클에서 순서대로 처리될 수 있으며, 이를 통해 상태 업데이트의 배치와 지연 처리가 가능해집니다.

### 여기서 복습 시간이 왔습니다~!

❓ 태스크 큐, 마이크로 태스크 큐 등 다양한 작업이 있고,이 안에서 동기적인 함수와 비동기적인 함수가 제각기 다른 우선순위로 호출된다는 것을 우리는 알고 있지요?

그렇다면, setState를 호출해서 state가 업데이트 되었고, 이로 인해 리렌더링이 발생한다면 이와 같은 작업들이 어떤 순서로 동작하며, 어디에 저장되나요?

#### 답변 필요 개념

- 이벤트 루프
- React의 내부 스케줄링 시스템

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

### 💡 정답

이 개념은 setState의 호출부터 리렌더링이 화면에 반영되기까지의 과정을 세 단계로 나눠서 알아보도록 하겠습니다

#### 1단계 : React 내부 스케줄링

setState가 호출되는 순간, 작업은 브라우저 큐에 바로 들어가지 않습니다.

- 업데이트 큐 저장 : 상태 변경 요청은 해당 **파이버 노드**의 **업데이트 큐**에 저장됩니다.
  => `global.states[index] = value`와 비슷하다고 할 수 있죠? (실제로는 함수/값의 큐)
- 우선순위 부여 (Lanes) : React는 이 업데이트에 **우선순위**를 부여합니다.
  => 사용자와의 상호작용(클릭, 입력)은 높은 우선순위를, 데이터 패칭같은 백그라운드 작업은 낮은 우선순위를 갖습니다

👌 우선 순위를 부여해서 업데이트 큐에 쌓았으니, 쌓은 것들을 언제 실행할 지 정해야겠지요?

❓ React Scheduler가 이 작업을 실행하도록 브라우저에게 요청할 때, 높은 우선순위의 동기적인 UI 업데이트를 위해 브라우저의 어떤 API를 사용하여 즉시 실행을 예약하려고 할까요??

> 힌트 : 브라우저가 다음 페인트 이전에 실행을 보장하는 API 입니다.
> 리액트의 훅이 아닌, 브라우저 API 입니다..!

🤔 뭘까용?

#### 2단계 : 브라우저 (Execution Context)

실제로는 더 복잡하고 브라우저나 React 버전마다 다르지만, 핵심 원리는 같습니다

| 큐 종류                    | React의 사용 목적        | 실제 사용 API (예시)       |
| -------------------------- | ------------------------ | -------------------------- |
| 마이크로태스크 큐          | 사용하지 않음            | Promise, queueMicrotask    |
| 매크로태스크 큐(태스크 큐) | 일반적인 비동기 스케줄링 | setTimeout, MessageChannel |
| 애니메이션 프레임          | UI 연속성 보장           | requestAnimationFrame(rAF) |

리액트는 마이크로태스크 큐를 사용하지 않습니다

#### ❓ Why?

마이크로태스크 큐의 작업은 현재 태스크가 끝난 직후에 실행되며, 다음 렌더링(Paint) 전에 처리되어야 합니다.

- 만약 React 가 Fiber 작업을 마이크로태스크로 예약하면, 브라우저의 UI 렌더링을 막고 긴 작업을 강제로 끝내야 하므로, Fiber의 핵심 목표인 중단 가능성이 파괴되기 때문입니다.

결국, React는 마이크로태스크 또는 rAF를 사용하여 작업을 예약하고, 브라우저가 잠시 숨을 돌릴 수 있는 유휴 시간을 확보하도록 합니다.

### 3단계 : Fiber의 실행 (Render/Commit)

스케줄링된 작업이 브라우저의 이벤트 루프에 의해 실행될 차례가 되면, 실제 Fiber 작업이 시작됩니다.

1. Render Phase (작업/조정 단계)

- 이 단계는 중단될 수 있습니다.
- React는 이전 파이버 트리와 새롭게 업데이트된 상태를 비교하여 Side Effect List, 즉 DOM에 실제 반영할 변경 사항 목록을 만듭니다.
  - 이 단계에서 useState, useMemo, useEffect 등의 훅(Hook)이 실행되어 새로운 상태값을 계산하고 Side Effect 함수들을 예약합니다
- DOM 업데이트 후, useEffect 등의 Side Effect 함수들이 실행됩니다.

#### 요약

setState 호출은 React Schedular를 거쳐 브라우저의 매크로태스크 큐나 rAF로 최종 예약됩니다.
