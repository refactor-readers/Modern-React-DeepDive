#### 딥다이브!

앞서 훅의 호출 순서가 보장되어야 하는 이유를 퀴즈로 내봤는데용, 해당 부분의 동작을 좀 더 자세히 알아보다보니, Linked List를 기용하고 있는 부분이 많아 좀 더 딥다이브 해보고 싶어져 내용을 가져와봤습니다.

간단하게 useState를 구현한 구조를 봤을 때는 `global.states`를 배열로 설명하고 있는데요, 실제 구현에서는 Linked List를 통해서 훅의 순서를 보장하고 있다고 합니다.

왜 리액트는 Linked List를 선택한 건지 좀 더 자세하게 알아볼까요???

### 리액트가 memoizedState에 배열 대신 연결 리스트(Linked List) 구조를 선택한 이유

#### 구조 변경의 효율성

React는 훅 이외에도 파이버 트리 전체를 연결 리스트 형태로 관리합니다. 연결 리스트는 중간에 요소를 추가하거나 제거할 때, 배열 처럼 뒤의 모든 요소를 밀거나 당길 필요 없이 앞뒤 노드의 **포인터**만 수정하면 되기 때문에 매우 효율적입니다.

=> 시간 복잡도 O(1) 를 가진다고 할 수 있지요

해당 효율성은

- 컴포넌트가 마운트(추가)되거나, 언마운트(제거)되어 파이버 트리의 구조가 동적으로 변경될 때 큰 성능 이점을 제공합니다 !

#### 복잡한 데이터 저장 능력

Hooks Linked List의 각 노드(Hook Object)는 단순히 상태 값만 저장하는 배열 슬롯이 아닙니다. 이 노드는 Hook의 모든 메타데이터를 담는 컨테이너 역할을 합니다.

### ❓ Q. 그렇다면 Hook의 관점에서, 이 노드에 현재 상태값 (예: 'A', 0) 외에 리액트가 비동기적으로 상태를 업데이트하기 위해 반드시 저장해야 하는 핵심 정보는 무엇일까요??

한 번 생각해보시라 공백을 넣어보도록 하겠습니다.

> 힌트 : `setState`를 호출하면 이 요청은 바로 반영되지 않고, 어딘가에 대기하고 있어야 합니다.

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

### 💡 정답

#### Update Queue (업데이트 큐)

정답은 Hook 객체가 현재 상태 값(`memoizedState`)외에 반드시 저장해야 하는 핵심 정보는 바로 **업데이트 큐** 입니다.

책에 나오는 useState의 약식 구현코드는 setState가 호출되면 `global.states` 배열의 값을 "즉시" 변경했지만, 실제 React Fiber에서는 다음과 같은 과정을 거칩니다

1. 사용자가 setValue(newValue)를 호출합니다
2. React는 새로운 상태 값이나 업데이트 함수(예: prev => prev + 1)를 담은 업데이트 객체를 만들고, 이 객체를 해당 Hook 노드에 있는 연결 리스트 형태의 큐에 추가합니다.
3. React는 이 큐에 업데이트가 있음을 확인하고, 스케줄러에게 "이 컴포넌트를 다시 렌더링해야 한다" 라고 알린다 (즉시 실행 X 비동기 예약)
   => 여기서 React Fiber의 역할인 스케줄링이 드러나죠?

이 update Queue 덕분에 여러 번의 setState 호출이 하나의 렌더링 사이클에서 순서대로 처리될 수 있으며, 이를 통해 상태 업데이트의 배치와 지연 처리가 가능해집니다.

### 여기서 복습 시간이 왔습니다~!

❓ 태스크 큐, 마이크로 태스크 큐 등 다양한 작업이 있고,이 안에서 동기적인 함수와 비동기적인 함수가 제각기 다른 우선순위로 호출된다는 것을 우리는 알고 있지요?

그렇다면, setState를 호출해서 state가 업데이트 되었고, 이로 인해 리렌더링이 발생한다면 이와 같은 작업들이 어떤 순서로 동작하며, 어디에 저장되나요?

#### 답변 필요 개념

- 이벤트 루프
- React의 내부 스케줄링 시스템

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

### 💡 정답

setState로 인한 작업들은 **Fiber 객체의 updateQueue**에 저장되며, 리액트 스케줄러에 의해 마이크로태스크 큐에 등록되어 비동기적으로 시작됩니다. 하지만 계산이 끝난 후 DOM을 바꾸는 Commit 단계는 동기적으로 처리되어 화면의 일관성을 보장하고, 상대적으로 덜 급한 useEffect는 태스크 큐로 보내져 화면이 그려진 뒤에 실행됩니다.

해당 답변에 대한 개념을 정리해보겠어요~!

#### setState 호출 : 마이크로태스크 큐의 시작

`setState`가 호출되면 리액트는 즉시 렌더링을 시작하지 않습니다. 대신 업데이트 작업을 예약합니다.

- 상태 업데이트 예약 : 호출된 `setState`는 해당 컴포넌트의 Fiber 객체 내의 updateQueue에 저장됩니다
- 스케줄링 : 리액트의 스케줄러가 이 작업의 우선순위를 결정합니다.
- 큐 등록 : 대부분의 상태 업데이트는 브라우저의 마이크로태스크 큐에 등록됩니다.
  => ❓Why? 현재 실행 중인 자바스크립트 코드(동기 함수)기 끝나자마자 바로 실행하려고

#### React Schedular와 우선순위 (Lane Model)

리액트는 업데이트에 우선순위를 나눕니다

- Lane 시스템 : 리액트는 내부적으로 Lane이라는 비트마스크를 사용해서 우선순위를 구분합니다
  - 클릭 이벤트는 높은 우선순위, 데이터 패칭 후 업데이트는 낮은 순위
- 스케줄러의 개입 : 만약 여러 개의 `setState`가 거의 동시에 발생하면, 리액트는 이를 하나로 묶는 Batching을 수행합니다. 이 작업 역시 마이크로태스크 큐에서 처리되어 불필요한 리렌더링을 방지합니다.

#### Render Phase: Work-in-Progress 트리 생성

이벤트 루프가 동기 스택을 비우고 마이크로태스크 큐에 있는 리액트의 렌더링 작업을 꺼내면, 본격적인 Render Phase가 시작됩니다.

- 동작 : 리액트는 메모리에 Work-in-Progress(WIP) 트리를 만들기 시작합니다.
- 중단 간으성 : 이 작업은 '비동기적'으로 쪼개질 수 있습니다. 만약 브라우저에 더 급한 작업(애니메이션, 사용자 입력)이 들어오면, 리액트는 WIP 트리 생성을 잠시 멈추고, 메인 스레드를 브라우저에 양보했다가 나중에 다시 돌아옵니다

#### Commit Phase & Layout Effects (동기적 실행)

WIP 트리가 완성되어 "무엇을 바꿀지" 계산이 끝났다면, 이제 실제 DOM에 반영할 차례입니다~!
이 단계는 일관성을 위해 중단 없이 동기적으로 실행됩니다.

- Mutation : 리액트가 실제 DOM 포인터를 조작하고 노드를 업데이트 합니다.
- useLayoutEffect: DOM 업데이트 직후, 브라우저가 화면을 그리기(Paint) 전 단계에서 동기적으로 실행됩니다 (브라우저 이벤트 루프 붙잡고 있음)
- Passive Effect (useEffect) 예약: useEffect는 바로 실행되지 않고, 블아ㅜ저가 화면을 그린 후에 실행되도록 태스크 큐에 예약 됩니다

#### 브라우저 렌더링과 useEffect 이벤트 루프의 완성~

- Paint : 브라우저가 메인 스레드를 점유하여 드디어 화면을 픽셀로 그립니다
- useEffect 실행 : 화면이 그려진 후, 이벤트 루프는 태스크 큐에 담겨있던 useEffect 콜백 함수를 꺼내 실행합니다.

| 순서 | 단계          | 작업 위치         | 특징                                       |
| ---- | ------------- | ----------------- | ------------------------------------------ |
| 1    | setState 호출 | 호출 스택 (Sync)  | updateQueue에 변경 사항 저장               |
| 2    | 업데이트 예약 | 마이크로태스크 큐 | 이벤트 루프가 스택을 비우면 즉시 실행 준비 |
| 3    | Render Phase  | Heap (Fiber Tree) | WIP 트리 계산. 우선순위에 따라 중단 가능   |
| 4    | Commit Phase  | 실제 DOM / 스택   | DOM 반영 및 useLayoutEffect 실행 (동기)    |
| 5    | Browser Paint | GPU / Compositor  | 사용자 눈에 화면이 보임                    |
| 6    | Effect Phase  | 태스크 큐         | useEffect 실행                             |
