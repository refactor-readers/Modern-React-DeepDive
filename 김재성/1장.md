# 1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스트립트의 동등 비교

###  자바스크립트의 데이터 타입

- 원시타입(값을 저장)
  - boolean
  - null
    - typeof null === 'object'
      - 자바스크립트가 값을 표현하는 방식 때문
      - null과 object를 구분하는 방식이 값음
      - ===null로 구분 필요
  - undefined
  - number
  - string
  - symbol
  - bigint

- 객체 타입(참조를 저장)
  - object
    - 참조형이라 값이 같아도 참조가 달라 비교해도 false

### 리액트에서의 동등 비교
Object.is를 사용하고 레거시 호환성을 위해 폴리필을 제공한다
추가로 Object.is를 기반으로 동등 비교하는 shallowEqual이라는 함수를 만들어 사용한다

차이점은 Object.is를 수행한느 것뿐만 아니라 객체 간의 비교도 추가되어 있다

단, 객체의 1depth까지는 비교가 가능하고 그 이상을 불가하다

왜냐하면 리액트의 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분하기 때문이다

만약 더 깊은단계까지 비교했다면 성능의 악영향을 미쳤을것이다

### 정리
2depth 이상 있는 props를 전달한다면 동등비교에서 false가 나와서 메모이제이션된 컴포넌트를 반환하지 못한다
메모이제이션을 유지하기 위해선 props를 serialization하는것이 필요하다

<br/>

## 1.2 함수

**함수 선언문**
```js
function add(a,b){
  return a+b
}
```
**함수 표현식**
```js
const sum = function(a,b){
  return a+b
}
```

두 정의방식의 차이는 선언문의 '호이스팅'유무이다 미리 선언전에 메모리에 할당하여 사용가능한 상태를 의미하고 표현식은 호이스팅 되지 않는다

<br/>

**화살표 함수**
```js
const add = (a,b)=>{
  return a+b
}
```

특징으로는 constructor를 사용할 수 없고 arguments가 존재하지 않는다

가장 큰 차이점으로는 this바인딩이다 this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이며

일반함수는 this가 전역 객체를 가리키고 화살표 함수는 상위스코프의 this를 따르게 된다


### 그외 함수 정의

**즉시 실행 함수**
```js
//선언식
(function (a,b){
  return a+b
})(10,24)

//화살표
((a,b)=>{
  return a+b
})(10,24)
```

**고차함수**
```js
// 함수를 매개변수로 받는 고차함수
const doubledArray = [1,2,3].map((data)=> data*2)
```

### 함수 만들때 주의사항
- **함수의 부수효과를 최대한 억제하라(sideEffect)**
- **가능한 한 함수를 작게 만들어라**
- **누구나 이해할 수 있는 이름을 붙여라**

<br/>

### 1.3 클래스

- constructor(생성자)
- 프로퍼티(내주 속성값)
- getter, setter(데이터 IO)
- 인스턴스 메서드(인스턴스에서 접근가능한 매서드)
- 정적 메서드(클래스명으로 호출 가능한 메서드)
- 상속(부모 클래스의 확장)

클래스는 프로토타입을 기반으로 작동한다

<br/>

### 1.4 클로저

"함수와 함수가 선언된 어휘적 환경(Lexical Scope)"

외부함수의 환경을 기억하고(힙 메모리에 저장) 이를 내부 함수에서 가져다 쓰는 매커니즘

리액트 훅에서 주로 쓰이고 대표적인 예시가 useState이다
> setState가 최신값(prev)를 알고있는 이유이다

<br/>

### 1.5 이벤트 루프와 비동기 통신의 이해

자바스크립트는 싱글 스레드
- 동기: 직렬
- 비동기: 병렬

**이벤트 루프**
- call stack(js에서 수행해야할 코드나 함수를 stack으로 담아두는것)이 비어있는지 여부를 확인하는 것
- 태스크 큐: setTimeoutm setInterval, setImmediate
- 마이크로 태스크 큐: process.nextTick, Promise, queueMicroTask, MutationObserver

실행 순서 : 동기 코드 -> 마이크로 태스크 큐 -> 렌더링 > 태스크 큐

<br/>

### 1.6 리액트에서 자주 사용하느 자바스크립트 문법
**배열 분해 할당 및 전개**
```js
const array = [1,2,3,4]
const [a,b, ...rest] = array
// 1, 2, [3,4]
```
**객체 분해 할당 및 전개**
```js
const obj = {
  a:1,
  b:2,
  c:3,
  d:4
}
const {a,b, ...rest} = array
// 1,2, {c:3,d:4}
```
**useState**
```js
const [state, setState] = useState() 
```
useState가 배열을 반환하는 이유는 구조분해 할당 시 작명을 자유롭게 할 수 있기 때문

**구조 분해 할당의 이점**
1. 필요한 값만 뽑아 메모리연산을 줄임
2. 불필요한 객체 참조를 줄여 렌더링 최적화
3. 중복코드 최소화
4. 의존성 배열 관리 용이