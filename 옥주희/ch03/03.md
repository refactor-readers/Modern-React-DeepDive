# 03. 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 useState

```js
export default function Component() {
  const [, triggerRender] = useState();

  let state = "hello"; // 상위 스코프

  function handleButtonClick() {
    state = "hi"; // 재할당
    triggerRender(); // setState()호출하나 state는 변화 x -> 리렌더 발생 x
  }
  return (
    <>
      <h1>{state}</h1>
      <button onC lick={handleButtonClick}>
        hi
      </button>
    </>
  );
}
```

#### | 왜 렌더링이 발생하지 않을까?

handleButtonClick 함수가 호출되어 런타임에 state="hi" 코드를 타는 순간 상위 스코프의 지역변수 state의 값이 재할당된다. 그러나 setState를 호출해도 state의 변화가 없어서 Component는 리렌더가 발생하지 않는다.

또한 리렌더가 발생한다해도 함수 스코프 내의 지역변수인 state는 Component함수가 렌더될 때 재선언, 재할당이 발생해 컴포넌트가 렌더될 때마다 초기값인 'hello'가 할당된다.

```js
function useState(initialValue) {
  let = initialValue;

  function state() {
    return internalState;
  }
  function setState(newValue) {
    internalState = newValue;
  }
  return [state, setState];
}
const [value, setValue] = useState(Ø);
setValue(l);

console.log(value()); // 1
```

> #### 클로저
>
> 어떤 함수(useState) 내부에 선언된 함수(setState)가 함수의 실행이 종료된 이후에도 (useState가 호출 이후 pop) 지역변수 state를 계속 참조할 수 있도록 해준다.
>
> 클로저를 사용해 구현되어 외부에 값을 노출시키지 않고, 컴포넌트 실행시에도 useState에서 이전의 값을 기억할 수 있었다.

#### | useReducer로 구현

실제 useState는 useReducer를 이용해 구현했다.

#### | 게으른 초기화(lazy initialization)

- 초기값으로 변수 대신 함수를 넣는 것
- state가 처음 만들어질 때만 사용(마운트)
- 리렌더시 함수실행 x

```js
import { useState } from "react";

export default function App() {
  const [state, setState] = useState(() => {
    console.log("복잡한 연산..."); // App 킴포넌트가 처음 구동될 때만 실행되고, 이후 리렌더링 시에는실행되지 않는다.
    return 0;
  });

  function handleClick() {
    setState((prev) => prev + 1);
  }

  return (
    <div>
      <h1>{state}</h1>
      <button onclick={handleClick}>+</button>
    </div>
  );
}
```

#### | 게으른 최적화

- 무거운 연산이 요구될 때
  - localStorage,
  - sessionStorage 접근
  - map, filter, find와 같은 배열에 대한 접근
- 실행비용이 많이 드는 경우 사용

### 3.1.2 useEffect

애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. 부수 효과가 언제 일어나느닞보다 어떤 상태값들과 함께 실행되는지 살펴보는 것이 중요하다.

- useEffect는 두개의 인수를 받는다(콜백, 의존성배열)
- 의존성배열의 값이 변경되면 첫번째 인수인 콜백을 실행한다.
  - [], [state1,state2,state3...], 생략가능
- 클래스형 컴포넌트의 생명주기 메서드와 비슷한 작동을 구현할 수 있다.
- 의존성배열에 [] -> 마운트시에만 실행
- 클린업 함수를 반환할 수 있고, 언마운트시에 실행된다.

#### | useEffect란?

useEffect는 어떻게 의존성 배열의 값이 변경된 걸 알 수 있나?

> #### 함수형 컴포넌트
>
> 함수형 컴포넌트는 매번 함수를 실행해 렌더링을 수행하며, 렌더링 시마다 고유한 state, props 값을 가지고 있다.

- 컴포넌트가 렌더링 될 때마다 의존성에 있는 값을 보며, 값이 변화할 때마다 부수효과를 실행하는 함수이다. (부수 효과 함수)

#### | 클린업 함수의 목적

- useEffect내에서 언마운트시 반환되는 함수
- 일반적으로 이벤트를 등록하고 지울 때 사용한다고 알려져 있다.

```js
import { useState, useEffect } from "react";

export default function App() {
  const [counter, setCounter] = useState(0);

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  useEffect(() => {
    function addMouseEvent() {
      console.log(counter);
    }

    window.addEventListener("click", addMouseEvent);

    return () => {
      console.log("클린업 함수 실행!", counter);
      window.removeEventListener("click", addMouseEvent);
    };
  }, [counter]);

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- 클린업함수는 이전 state를 참조해 실행된다.
- 새로운 값을 기반으로 렌더링 뒤에 실행되지만, 함수가 정의됐을 당시에 이전 값을 보고 실행된다.

```js
// 최초실행
useEffect(() => {
  function addMouseEvent() {
    console.log(1);
  }

  window.addEventListener("click", addMouseEvent);

  // cleanup 함수, 다음 렌더링이 끝난 뒤 실행
  return () => {
    console.log("클린업 함수 실행!", 1);
    window.removeEventListener("click", addMouseEvent);
  };
}, [counter]);

// 이후 실행
useEffect(() => {
  function addMouseEvent() {
    console.log(2);
  }

  window.addEventListener("click", addMouseEvent);

  // cleanup 함수, 다음 렌더링이 끝난 뒤 실행
  return () => {
    console.log("클린업 함수 실행!", 2);
    window.removeEventListener("click", addMouseEvent);
  };
}, [counter]);
```

- 클린업 함수가 useEffect내에 존재하면 클린업 함수를 먼저 실행한 뒤, 콜백함수를 실행한다.

  - 이벤트 핸들러가 무한히 추가되지 않도록, 다음 콜백을 실행하기 전 클린업함수를 실행해 이전 이벤트를 삭제하는 것이다.

  > #### 언마운트(unMount)
  >
  > 클래스형 컴포넌트의 용어로 특정 컴포넌트가 완전히 DOM에서 사라지는 것을 의미한다.

- clean up은 이전의 효과를 정리하고 다음 효과로 넘어가기 위한 정리 함수(상태 청소 개념)
- 클린업함수는 의존성 배열이 변경되어 함수가 리렌더링 될때 이전값을 기준으로 한번 실행되는 함수로, 이전의 상태를 청소해주는 개념으로 보는 것이 옳다.

#### | 의존성 배열

- x
  - 랜더링시마다 실행
    - 렌더링 확인용으로 사용 가능
- []
  - 최초 렌더링 직후 실행, 이후 재실행 x
- [state]
  - 최초 렌더링 직후 실행, state가 변경될 때마다 재실행
- 의존성 배열의 이전 값과 현재 값의 비교는 얕은 비교이다.

```js
// 렌더시
// 1. 렌더시에 콘솔 출력
function Component() {
  console.log("렌더링됨");

  return <div>Hello</div>;
}

// 렌더 후
// 2. 렌더 -> ui update(dom) -> useEffect
function Component() {
  useEffect(() => {
    console.log("렌더링됨");
  });

  return <div>Hello</div>;
}
```

1. 서버사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해준다.

- useEffect내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.

2. 컴포넌트가 렌더링된 이후에 실행된다. 반면 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다. 즉, **서버 사이드 렌더링의 경우 서버에서도 실행된다**. 함수형 컴포넌트의 반환을 지연시키며 무거운 작업일 경우 렌더링을 방해해 성능에 악영향을 줄 수 있다.

- effect는 사이드 이펙트(부수효과)를 의미하며, 컴포넌트 렌더링 이후에 부수 효과를 일으키고 싶을 때 사용하는 훅이다.

#### | useEffect를 사용할 때 주의할 점

| eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라

```js
useEffect(() => {
  conso1e.log(props);
}, []); // es1int-disab1e-1ine react-hooks/exhaustive-deps
```

- 의존성 배열을 넘기지 않은 채 콜백 함수를 사용한다는 건, 실제 값을 관찰해서 실행되는 동작과는 별개롸 동작하는 것을 의미
- 빈배열을 넘기기 전에는 정말로 useEffect의 부수 효과가 컴포넌트의 상태와 별개인지 검토해봐야한다.

| useEffect 의 첫 번째 인수에 함수명을 부여하라

- 코드가 복잡해질 때 해당 함수의 왜 만들어졌는지 파악하기 좋다.

```js
useEffect(
  function logActiveUser() {
    logging(user.id);
  },
  [user.id]
);
```

| 거대한 useEffect를 만들지 마라

- 렌더링에 영향을 미쳐 앱 성능에 영향이 있을 수 있다.
- 작게 쪼게 여러개의 useEffect로 나누는 것이 좋다.

### 3.1.3 useMemo

- 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 저장된 값을 반환하는 훅이다.

```js
import { useMemo } from "react";

const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b]);
```

- useMemo(생성함수, 의존성배열)
- 의존성 배열의 값이 변경되지 않았으면, 함수를 재실행하지 않는다.
- 컴포넌트 함수에서도 사용이 가능하다
  - useMemo로 검포넌트를 감쌀 수 있으나, React.memo를 쓰는게 더 현명하다.

### 3.1.4 useCallback

- useMemo가 값을 기억했다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다.
  - 함수를 새로 만들지 않고 다시 재사용한다.

```js
const ChildComponent = memo(({ name, value, onChange }) => {
  // 렌더링이 수행되는지 확인하기 위해 넣었다.
  useEffect(() => {
    console.log("rendering!", name);
  });

  return (
    <>
      <h1>
        {name} {value ? "켜짐" : "꺼짐"}
      </h1>
      <button onClick={onChange}>toggle</button>
    </>
  );
});

function App() {
  const [status1, setStatus1] = useState(false);
  const [status2, setStatus2] = useState(false);

  const toggle1 = () => {
    setStatus1(!status1);
  };

  const toggle2 = () => {
    setStatus2(!status2);
  };

  return (
    <>
      <ChildComponent name='1' value={status1} onChange={toggle1} />
      <ChildComponent name='2' value={status2} onChange={toggle2} />
    </>
  );
}
```

- 부모 컴포넌트의 state가 바뀌고 리렌더링 되면서, 그때마다 onChange에 전달하는 toggle함수가 재생성되는 것.
- 즉, useMemo가 값의 메모이제이션을 위해 사용됐다면, useCallback은 함수의 메모이제이션을 위해 사용한다.
- 두번째 인수인 의존성 배열이 변경되지 않으면 함수를 재생성하지 않는다.
  - 함수가 재생성되지 않아 메모리 주소가 동일하고, useMemo는 얉은 비교시 변경 사항이 없으므로 자식 컴포넌트를 렌더하지 않는다.

```js
function App() {
  // ...
  const toggle1 = useCallback(
    function toggle() {
      setStatus1(!status1);
    },
    [status1]
  );

  return (
    <>
      <ChildComponent name='1' value={status1} onChange={toggle1} />
    </>
  );
}
```

| useCallback과 useMemo

- 메모이제이션의 대상이 변수인지 함수인지만 다름

### 3.1.5 useRef

- 컴포넌트 내부에서 렌더링이 일어나도 **변경 가능한 상태값**을 저장한다는 공통점이 있다.

#### | useState와 구별되는 큰 차이점

- useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다
- 렌더링에 영향을 미치지 않는 고정된 값을 관리하기 위해 useRef를 사용한다.
- 컴포넌트가 렌더링 될 때 생성되며, 컴포넌트의 인스턴스가 여러 개라도 각각 별개의 값을 바라본다.
- 일반적인 사용의 예는 DOM 접근
- 개발자가 원하는 시점의 값을 렌더링 영향 없이 보관하고 싶다면 useRef

### 3.1.6 useContext

| Context와 props drilling

- 리액트는 트리 구조라서, 하위 컴포넌트에 값을 전달하려면 props를 계속 아래로 전달(props drilling) 해야 한다.
- 이걸 줄이기 위해 나온 개념이 Context
  - 명시적으로 props를 넘기지 않아도, Provider로 감싼 하위 컴포넌트 어디에서나 값에 접근할 수 있다.

| useContext란?

- 만들어 둔 Context를 함수형 컴포넌트 안에서 사용하는 훅.
- 즉, Context.Provider가 제공한 값을 직접 꺼내 쓰기 위한 도구.

```js
const MyContext = createContext();

function App() {
  return (
    <MyContext.Provider value={{ theme: "dark" }}>
      <Child />
    </MyContext.Provider>
  );
}

function Child() {
  const { theme } = useContext(MyContext);

  return <div>현재 테마: {theme}</div>;
}
```

- useContext(SomeContext)를 호출하면,
  - 가장 가까운 SomeContext.Provider의 value를 가져온다.
  - Provider가 여러 개 중첩돼 있어도 **가장 가까운 것**을 기준으로 한다.

| Context = 상태관리 라이브러리가 아님

- 컨텍스트는 상태를 주입해주는 API이다.
- Context는 단순히 값을 트리 아래로 전달하는 역할만 한다.
- 어떤 상태에서 다른 상태를 계산하는 기능은 없음
- 렌더링 최적화도 자동으로 해주지 않음
  > #### 상태 관리 라이브러리가 되기 위한 조건
  >
  > - 어떤 상태를 기반으로 다른 상태를 만들어낼 수 있어야 한다.
  > - 필요에 따라 상태 변화에 대한 렌더링을 최적화할 수 있어야 한다.
- 그래서 Context는 상태 관리 도구가 아니라 전달 경로를 단축해 주는 통로 정도로 이해하는 게 맞다.

### 3.1.7 useReducer

| useState와 차이점

- 겉으로 보면 반환값은 useState와 동일하다 (길이가 2인 배열)
- 하지만 사용 목적이 다르다
  - useState: 단일 상태를 단순하게 바꿀 때 사용
  - useReducer: 복잡한 상태를 미리 정의된 시나리오(action)에 따라 변경하고 싶을 때 사용

#### | 인수

1. reducer

- `(state, action) => newState` 형태의 함수

2. 초깃값 (initialState)

3. 옵션 (init)

- 지연 초기화용 함수(있을 수도, 없을 수도 있음)

#### | 목적

- 상태 변경 방법을 컴포넌트 바깥(reducer) 에 모아두고,
- 컴포넌트 안에서는 `dispatch({ type: '...' })` 같은 액션만 보냄
  - 어떻게 바꿀지는 reducer에서 관리
  - 언제 바꿀지는 컴포넌트에서 관리하
- 이렇게 하면

  - 상태를 변경하는 시나리오가 제한적이어서 흐름이 명확해진다.
  - 액션 별로 상태 변화를 추적하고 테스트하기 쉬워진다.

### 3.1.8 useImperativeHandle

#### | forwardRef 살펴보기

- ref도 key처럼 리액트에서 의미 있는 예약어다.
- 기본적으로 ref는 DOM에 직접 접근하기 위한 용도로 쓰인다.

```js
function Input() {
  return <input />;
}

// 부모
const ref = useRef();
<Input ref={ref} />;
```

- ref를 자식 컴포넌트에 props처럼 넘겨서 자식 내부에서 쓰고 싶다면 `forwardRef`를 사용하면 된다.

#### | useImperativeHandle이란?

- 부모에게서 받은 ref에 원하는 값/동작을 직접 정의할 수 있게 해주는 훅이다

#### | 원래 ref의 형태 vs useImperativeHandle 이후

- 원래 ref는 보통 이런 형태

```js
ref.current; // HTMLElement 같은 실제 DOM 객체
```

- useImperativeHandle을 사용하면

```js
ref.current; // { alert: () => {...}, ... } 이런 식으로 커스텀 객체
```

- ref가 가리키는 값을 DOM만이 아니라, 내가 정의한 임의의 객체로 만들 수 있다.
- 부모 컴포넌트는 자식이 노출해준 메서드만 호출할 수 있다 → 캡슐화 느낌.

### 3.1.9 useLayoutEffect

#### | useEffect와의 차이

- useLayoutEffect의 형태는 useEffect와 똑같지만 실행 타이밍이 다르다.

#### 실행 순서:

1. 리액트가 DOM을 업데이트
2. useLayoutEffect 실행 (동기적으로)
3. 브라우저가 화면에 변경 사항을 그림(페인트)
4. 그 후에 useEffect 실행

- useLayoutEffect: 화면에 그려지기 전에 실행
- useEffect: 화면에 그려진 후 실행

#### | 동기적으로 발생한다는 의미

- 리액트는 useLayoutEffect가 끝날 때까지 다음 작업으로 넘어가지 않는다. (화면 그리기도 잠시 멈춤)
- 그래서 useLayoutEffect 안에서 무거운 작업을 하게되면
  - 컴포넌트가 잠깐 멈춘 것처럼 보일 수 있다.
  - 앱의 성능에 문제가 생길 수 있다.

#### | 언제 쓰면 좋을까?

- DOM은 계산됐지만 그게 실제 화면에 반영되기 직전에 하고 싶은 작업이 있을 때.

  - 특정 DOM 요소 기반 애니메이션 시작 위치 잡기
  - 스크롤 위치 강제 조정
  - DOM 크기/위치 측정 후 스타일 조정 등

- 이런 작업을 useEffect로 하면 사용자가 잠깐 깜빡이는 걸 느낄 수 있음.
  - useLayoutEffect를 쓰면 그 전에 처리해서 더 자연스럽게 보이게 할 수 있다.

### 3.1.10 useDebugValue

#### | 무엇을 하는 훅인가?

- 커스텀 훅 내부에서 디버깅용 정보를 남기기 위한 훅이다.
- React DevTools에서 훅의 상태를 보기 좋게 표시하는 용도로 사용한다.
- 사용자 정의 훅 내부에서만 사용할 수 있다.
  - 컴포넌트 안에서 바로 호출하는 형태는 아니다.
- 첫 번째 인수의 값이 같으면 두 번째 인수(포매팅 함수)는 호출되지 않는다. (불필요한 계산 방지)
- 공통 훅을 제공하는 라이브러리로 규모가 큰 앱에서 내부 훅의 상태를 DevTools에서 보기 좋게 표시하고 싶을 때 활용한다.

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

### 3.2.1 사용자 정의 훅 (custom hook)

- 서로 다른 컴포넌트에서 같은 로직을 재사용하고 싶을 때 사용하는 패턴이다.
- use로 시작하는 함수 형태로 만들고 내부에서 다른 훅들을 조합해서 사용한다.

### 3.2.2 고차 컴포넌트(HOC)

#### | 고차 컴포넌트란?

- 컴포넌트를 입력으로 받아 새로운 컴포넌트를 반환하는 함수이다.
- 컴포넌트의 로직 자체를 재사용하기 위한 방법으로 사용한다.
- 리액트에서는 고차 컴포넌트를 사용해서
  - 중복 로직 모으기
  - 최적화
  - 공통 기능 주입 같은 기능을 구현할 수 있다.

#### | React.memo란?

- React.memo도 고차 컴포넌트의 한 종류이다.
- 기본적으로 리액트 컴포넌트는
  - 부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 props 변경 여부와 상관없이 다시 렌더링된다.
- 이때 props가 이전과 완전히 같다면(얕은 비교) 렌더링을 생략해주는 게 React.memo.

```js
import { useState, useEffect, ChangeEvent } from "react";

const ChildComponent = ({ value }: { value: string }) => {
  useEffect(() => {
    console.log("렌더링");
  });

  return <>안녕하세요! {value}</>;
};

function ParentComponent() {
  const [state, setState] = useState(1);

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setState(Number(e.target.value));
  }

  return (
    <>
      <input type='number' value={state} onChange={handleChange} />
      <ChildComponent value='hello' />
    </>
  );
}
```

- 이전 렌더 시점의 props와 현재 props를 얕은 비교를해서 props가 같다면 이전 결과를 재사용 (렌더 스킵)
- props가 다르다면 리렌더링한다.

### 3.2.3 custom hook vs 고차 컴포넌트

#### | custom hook (추천되는 경우가 많음)

- 렌더링에 직접 영향을 주지 않는다
  - 훅 내부 로직은 렌더링을 새로 만들어내지 않음
- 컴포넌트 내부의 로직을 개발자 의도대로 자유롭게 구성 가능
- 리액트가 제공하는 훅들로 공통 로직을 추출할 수 있다면 custom hook 사용하는 것이 더 안전하고 직관적

#### | 고차 컴포넌트 (사용 이유가 있을 때만)

- 고차 컴포넌트는 새로운 컴포넌트를 반환하기 때문에 렌더링에 영향을 준다.
- return되는 컴포넌트 구조를 예측하기 어려울 수 있다.
- 디버깅 시 현재 어떤 HOC가 감싸고 있는지 파악해야 해서 난이도가 올라간다.
- 아래와 같은 경우에 사용된다.
  - 렌더링 레벨에서 로직을 주입해야 하는 경우
  - 컴포넌트 외부에서 UI 로직을 제어하려는 경우
