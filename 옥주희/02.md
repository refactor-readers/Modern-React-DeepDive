# 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX(JavaScript XML)란?

자바스크립트 코드 내부에서 HTML과 유사한 문법을 사용할 수 있게 해주는 문법적 확장이다.
자바스크립트 표준 문법이 아니기 때문에 트랜스파일러(Babel)를 거쳐야 브라우저에서 동작한다.
본질적으로 JSX는 XML 형태의 **트리 구조**를 자바스크립트 안에서 쉽게 표현하기 위한 문법이다.

### 2.1.1 JSX의 구성 요소

<!-- JSX는 다음 네 가지 요소로 이루어진다. -->

1. JSXElement

- HTML 요소와 비슷한 구조
- div, component, <></>
- OpeningElement / ClosingElement / SelfClosingElement / Fragment

2. JSXAttributes

- JSXElement에 부여하는 속성, 필수값 x
- {...props}로 스프레드도 가능
- 문자열, {표현식}, JSXElement 등 다양한 타입 가능

3. JSXChildren

- JSXElement의 자식
- 텍스트, JSXElement, Fragment, {표현식} 등

4. JSXStrings

- HTML에서 가능한 문자열
- "text", 'text', JSXText
- HTML과 달리 자바스크립트의 이스케이프 제약을 받지 않는다.

### 2.14 JSX 정리

- JSX는 React에서 UI 구조를 가장 직관적으로 표현할 수 있는 방법이다.

<br/>

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

#### 브라우저가 화면을 그리는 과정

1. HTML 다운로드
2. HTML 파싱 → DOM 생성
3. CSS 다운로드
4. CSS 파싱 → CSSOM 생성
5. display:none을 제외한 노드 기반으로 렌더 트리 구성
6. 스타일 계산
7. 레이아웃(Reflow)
8. 페인팅(Paint)

- DOM을 조작하는 것은 비싸다 → SPA에서는 더 비싸짐 → 개선 필요

### 2.2.2 가상 DOM이 탄생 배경

- DOM 변경이 많아지는 SPA 환경에서 직접 DOM을 조작하는 건 비용이 크고 느림
- 변경 추적도 어려움

#### 해결책 = Virtual DOM

- 실제 DOM에 변경을 바로 반영하지 않고 메모리에서 가상의 DOM 트리를 구성
- 변경 사항을 모아서 한 번에 실제 DOM에 반영
- 브라우저의 부담을 줄이고 개발자의 코드도 단순화
- 항상 빠른 것이 아니라, 현대 웹앱을 만들기 충분히 빠르고 효율적인 방식

### 2.2.3 가상돔을 위한 아키텍쳐, 리액트 파이버

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 리액트 파이버
- 리액트 파이버는 파이버 재조정(Reconciliation)가 관리하며, 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집한다

#### 역할

- 가상 DOM과 실제 DOM을 비교해 변경사항을 수집
- 필요한 부분만 DOM 업데이트
- 렌더링 작업을 작게 쪼개 비동기적으로 처리
- 우선순위가 높은 작업 먼저 처리

#### Fiber의 두 단계

1. 렌더 단계 (Render Phase)

- 변경사항 계산, 우선순위 조절 가능
- 중단·재시작 가능

2. 커밋 단계 (Commit Phase)

- 실제 DOM 업데이트
- 화면에 영향 주는 유일한 시점

#### Fiber 트리 구조

- React는 current, workingProgress 두개의 트리를 유지한다.

  - current 트리 : 현재 화면에 보여지는 UI
  - workInProgress 트리 : 다음 렌더링을 위해 준비 중인 트리

- 작업이 끝나면 포인터만 교체하여 workInProgress → current로 변경하며 이걸 **더블 버퍼링**이라고 부른다.
- Fiber는 React 컴포넌트와 1:1로 대응되는 객체

<br/>

## 2.3 클래스형 컴포넌트와 함수형 컴포넌트

### 2.3.1 클래스형 컴포넌트

#### 클래스형 컴포넌트의 생명주기 메서드

| 메서드                   | 시점               |
| ------------------------ | ------------------ |
| componentDidMount        | 마운트 직후        |
| componentDidUpdate       | 업데이트 후        |
| componentWillUnmount     | 언마운트 직전      |
| shouldComponentUpdate    | 리렌더링 여부 결정 |
| getDerivedStateFromProps | render 직전        |
| getSnapShotBeforeUpdate  | DOM 업데이트 직전  |
| getDerivedStateFromError | 오류 발생 시       |
| componentDidCatch        | 오류 처리          |

#### 클래스형의 한계

- 데이터 흐름 추적 어려움
- 앱 내부 로직 재사용 어려움
- this 바인딩 문제
- 코드 복잡도 증가
- 번들 최적화 어려움
- 핫 리로딩이 발생하면 다시 기본값으로 돌아감

### 2.3.2 함수형 컴포넌트

#### 장점:

- this 필요 없음
- 더 간결하고 명확
- 상태가 원시값으로도 관리
- 훅을 통한 로직 재사용 용이

### 2.3.3 함수형 vs 클래스형

- 클래스형은 시간의 흐름에 따라 바뀌는 this 기반
- 함수형은 렌더링 순간의 props/state 기반
- 생명주기 메서드는 클래스형 전유 → 함수형에서는 useEffect 등으로 대응

<br/>

## 2.4 리액트 렌더링

브라우저 렌더링도 있기 때문에 리액트 렌더링과 혼용하면 안됨

### 2.4.1 렌더링은 어떻게 일어나는가?

#### 리액트의 렌더링

= 리액트 컴포넌트의 모든 props/state → UI 구성 → Virtual DOM → 실제 DOM

### 2.4.2 리액트의 렌더링이 일어나는 이유

리액트 렌더링 발생 시나리오

1. 최초 렌더링 수행 (마운트)
2. 리렌더링 (마운트를 제외한 모든 렌더링)

- useState()의 setter 실행(state 업데이트)
- useReducer()의 dispatch 실행

<!-- ```js
//key props
<li key={index}>{index}<li/>
``` -->

- 컴포넌트의 key props 변경 시(key는 특수한 props)
  <!-- - key는 동일 요소에 대한 식별값, index[0]을 기준으로 sibling -->
  - 리렌더링이 필요한 컴포넌트를 최소화
  <!-- - current와 workInProgress  -->
- props 변경 시
- 부모 컴포넌트 렌더링 시 -> 자식 컴포넌트 렌더링

### 2.4.3 리액트의 렌더링 프로세스

<!-- jsx문법은 React.createElement를 호출해 변환 -->

1. 업데이트가 필요한 컴포넌트
2. 클래스 : render(), 함수 : FunctionComponent() 실행
3. 자바스크립트 컴파일 : JSX를 React.createElement()를 호출해 변환
4. 이전 가상 DOM과 비교(재조정)
5. 변경 사항 하나의 동기 시퀀스로 모아서 DOM에 적용

### 2.4.4 랜더와 커밋

#### 리액트의 렌더링은 렌더 단계와 커밋 단계로 분리되어 실행

#### 렌더 단계(Render Phase)

컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업

- type, props, key 비교
- 변경사항 계산

#### 커밋 단계 (Commit Phase)

렌더 단계의 변경 사항을 실제 DOM에 적용하는 사용자에게 보여주는 과정. 리액트의 랜더링(렌더->커밋)이 끝나야 브라우저의 렌더링이 발생(리액트의 렌더링이 일어나도 커밋이 필요없으면 DOM업데이트 X)

- DOM을 커밋단계에서 업데이트
- 새로 만들어진 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트
- 클래스형 : 생명주기 메서드 호출, 함수형 : useLayoutEffect 훅 호출

#### 동시성 렌더링(리액트 18 도입)

- 렌더 단계가 비동기로 동작
- 브라우저의 동기작업을 차단하지 x

<br/>

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

### 2.5.1 주장 1 — 섣부른 최적화는 독이다.

#### 메모이제이션도 비용이 든다

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 결과 저장한 뒤 재사용하는 비용
- 렌더링도 비용이지만 메모리 저장도 비용
- 불필요한 메모이제이션 지양

### 2.5.2 주장 2 — 렌더링 과정의 비용은 비싸다. 모두 메모이제이션해 버리자

 <!-- 렌더링은 비싸니 메모이제이션을 전략적으로 -->

#### memo를 쓰지 않을 때 발생하는 문제점

리렌더링이 발생할 때 메모이제이션을 하지 않으면, 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다.

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부 복잡한 로직 재실행
- 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 발생
- 구트리와 신규 트리 비교 비용 증가

메모이제이션을 고려해야되는 상황

- 자식 컴포넌트에 props로 함수, 객체 전달
- 무거운 계산
- 렌더링이 잦은 리스트
- 재사용 가능한 로직
- memo / useCallback / useMemo 적절히 활용
