# 1.1 자바스크립트 동등 비교
## 1.1.1 자바스크립트의 데이터 타입

자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 크게 나뉜다.

### 원시 타입 (Primitive)
- 값 자체가 변수에 저장된다.  
- 불변(immutable)하며, 재할당하면 새로운 메모리가 생성된다.
    - boolean  
    - null  
    - undefined     
    - number  
    - string  
    - symbol  
    - bigint  

### 객체 타입 (Object)
- 원시 타입을 제외한 모든 타입으로 배열, 함수, 정규식, 클래스 등 포함   
- 참조값(메모리 주소)을 갖는 타입

객체 비교 시 값이 같아도 참조 주소가 다르면 false가 나온다.

## 1.1.2 값을 저장하는 방식의 차이
데이터 타입(원시, 객체)간에 값을 저장하는 방식의 차이가 동등 비교시에 차이를 만든다.
### 원시 타입
- 불변형태
- 변수 할당시점에 메모리 영역을 차지하고 저장(선언부는 undefined로 초기화)
- 재할당 시 새로운 메모리 공간에 실제 값을 저장

### 객체 타입
- 변경 가능한 형태(삭제, 추가, 수정 가능)
- 변수에는 객체가 저장된 메모리 주소(참조)가 저장
- 복사해도 참조(메모리 주소)만 복사됨
- 객체 간 비교가 발생하면 객체가 가리키는 메모리 주소가 같은지 확인해야됨

## 1.1.3 Object.is 비교
동등비교 ===이 가지는 한계를 극복하기 위해 만들어짐
- ===과 거의 동일하지만 몇 가지 예외를 명확하게 처리
- -0과 +0을 다르게 판별
- NaN은 자기 자신과 같다고 처리한다.

```js
Object.is(0, -0);    // false
Object.is(NaN, NaN); // true
```

## 1.1.4 리액트에서의 동등 비교
리액트는 Object.is() 기반으로 얕은 비교(shallow comparison)를 수행한다.
props는 객체이기 때문에 1 depth 수준에서만 비교해도 성능 측면에서 충분하다.
이를 기반으로 리렌더링 여부를 결정한다.
<br/>
<br/>
# 1.2 함수
## 1.2.1 함수란 무엇인가?
함수는 하나의 로직을 수행하기 위한 실행 단위

## 1.2.2 함수를 정의하는 4가지 방법
### 함수 선언문
- 표현식(값으로 평가될 수 있는 문), 
- 문(statement, 선언, 값으로 평가 x)
```js
function add(a, b) {
  return a + b;
}
```
### 함수 표현식
    일급객체
    - 다른 객체들에 일반적으로 적용 간으한 연산을 모두 지원하는 객체
        - 다른 함수의 매개변수, 반환값, 할당 가능    
```js
const sum = function(a, b) {
  return a + b;
};
```
#### 함수 표현식과 선언식의 차이 
- 호이스팅에서의 차이
    - 표현식은 함수가 변수에 할당된 것
    - 변수는 선언부만 호이스팅되고 값은 호이스팅되지 않음.
    - undefined로 초기화 (할당 이전에 error 발생이유)  
    - 런타임(평가시점)에 함수가 변수에 할당됨
- 적절하게 사용하면 됨
### 화살표 함수
```js
const add = (a, b) => a + b;
```
일반 함수와 화살표 함수의 차이점
- constructor 사용 불가
- arguments 존재 x
- this 바인딩은 렉시컬 바인딩을 따름(정적 결정)
    - 현재 this가 있는 상위 스코프의 this를 상속 

## 1.2.3 다양한 함수 살펴보기
### 즉시 실행 함수 (IIFE)
- 함수를 정의하고 즉시 실행, 일회성, 재호출 불가
- 글로벌 스코프 오염을 막고, 독립적인 스코프를 만듦
```js
((a, b) => a + b)(10, 20);
```


### 고차 함수
함수를 인수로 받거나 결과로 새로운 함수를 반환하는 함수(map, filter, reduce 등)

## 1.2.4 함수 작성 시 주의점

1. 함수의 부수효과(Side Effect)를 억제하라
- 부수효과 : 함수 외부에 영향을 끼치는 것
- 순수함수 : 부수효과가 없는 함수(동일 인수 -> 동일 결과 반환, 외부에 영향 x)
- React에서는 부수효과를 처리하는 훅(useEffect)의 사용 최소화
2. 가능한 함수를 작게 만들어라
- 함수를 작게 나눌것
3. 누구나 이해할 수 있는 이름을 붙여라
- 함수 이름은 간결하고 이해하기 쉽게 만들 것  

<br/>
<br/>

# 1.3 클래스
## 1.3.1 클래스란 무엇인가?
클래스는 특정한 형태의 객체를 만들기 위한 일종의 템플릿

### constructor (생성자)
- 생성자, 객체를 초기화하는 용도
- 인스턴스가 생성될 때 호출되며 객체를 생성하는데 사용되는 특수 메서드
- 클래스 내부에 하나만 존재 가능

### 프로퍼티
- 인스턴스 생성 시 내부에 정의하는 속성값
```js
class Car {
  constructor(name) {
    this.name = name; // 값을 받으면 내부 프로퍼티로 할당
  }
}
```

### getter와 setter
- 클래스에서 값을 가져올 때 사용. (get)
- 클래스 필드에 값을 할당할 때 사용. (get)

### 인스턴스 메서드
- prototype에 등록됨
- 프로토타입 체이닝을 통해 상위 메서드 접근 가능

### 정적 메서드
- 인스턴스가 아닌 클래스 자체에서 호출한다.
```js
class Car {
  static hello() {
    console.log('안녕하세요');
  }
}

Car.hello(); 
```

### 상속
```js
class SuperCar extends Car {}
```
- 기존 클래스를 기반으로 상속받아 자식 클래스로 확장하는 개념(extends)

<br/>
<br/>

# 1.4 클로저
## 1.4.1 클로저의 정의
- 함수와 함수가 선언된 어휘적 환경(렉시컬 스코프)의 조합
    - 렉시컬 스코프 : 변수가 코드 내부 어디에서 선언되었는가가 중요. 선언시 정적으로 결정됨 
- 외부 함수 실행이 끝난 후에도 내부 함수가 외부 함수의 변수에 접근 가능하다.
### 클로저 개념 추가 정리
- 함수가 만들어질 때의 외부 변수들을 기억하고, 그 함수가 종료된 뒤에도 계속 접근할 수 있게 해주는 것
    - 자바스크립트는 함수 선언시 렉시컬 스코프가 결정되고, 함수 실행시에 렉시컬 스코프 정보를 기반으로 렉시컬 환경(Lexical environment) 객체를 생성
    - 렉시컬 환경을 함수가 [[Environment]]라는 내부 슬롯에 저장함 
    - **Lexical Environment**
        - environment record(변수, 함수가 담겨있는 객체)
        - outer Environment Reference(상위 스코프를 가리키는 포인터)
        즉, 함수 실행시 렉시컬 환경이 생성되고, 렉시컬 환경 내부에 **상위 스코프**에 대한 링크가 연결되어있음
        - **스코프 체인**(outer -> outer -> ... glbal)이 만들어지는 것
        - 이 환경은 [[Environment]] 슬롯에 저장되어 있으며, 내부 함수가 외부 렉시컬 환경을 계속 **참조**하고 있어서 GC(garbage collect)가 해제하지 못함
        - 그래서 함수가 종료된 이후에도 클로저가 유지되고 외부 변수도 유지되는 것(외부 변수에 접근 가능한 이유)  

## 1.4.2 변수의 유효 범위(스코프)
- 변수의 유효범위에 따라 어휘적 환경(렉시컬 스코프)이 결정되고, 변수의 유효 범위를 스코프라고 한다.

### 전역 스코프
- 브라우저 환경 : window
- Node.js : global
- 전역 레벨에서 선언한 스코프가 바인딩된다

### 함수 스코프
- 함수 레벨 스코프, {}
- 중첩 스코프(현재 스코프 -> 상위 레벨 스코프 : 스코프체이닝)

## 1.4.3 클로저의 활용
### 리액트에서의 클로저
- useState가 클로저를 기반으로 동작 <br/>
- ~~외부함수(useState)가 반환한 내부함수(setState)는 외부함수가 실행 컨텍스트에서 종료(pop)되고, 내부함수(setState)를 실행중이나 함수의 내부 슬롯([[Environment]])에 저장된 record와 pointer를 기반으로 상위 스코프에 대한 링크를 유지하고있어서 해당 state의 값에 접근해 사용할 수 있는 것이다. (js-실행컨텍스트와 클로저의 개념으로 생각해봤는데 react의 useState 훅의 동작은 다르다고 함)~~
- 컴포넌트가 렌더링되면, useState는 state 값을 리액트 내부 Hook 저장소에 저장하고, setState는 그 저장소를 갱신할 수 있는 함수로서 클로저를 형성한다.
컴포넌트 함수의 실행 컨텍스트는 종료(pop)되지만, setState는 자신이 생성될 때 캡처한 Hook 저장 공간에 대한 참조([[Environment]]의 상위 스코프 링크)를 유지하고 있기 때문에, 컴포넌트가 이후에 다시 렌더링되더라도 최신 state에 접근하고 업데이트할 수 있다. (gpt 수정)

```js
setState(prev => prev + 1); // prev가 최신 상태값을 계속 유지하는 이유가 클로저 때문
```

<br/>
<br/>

# 1.5 이벤트 루프와 비동기 통신의 이해
자바스크립트는 싱글 스레드지만, 브라우저(Web API) 도움으로 비동기 처리가 가능하다.

## 1.5.1 이벤트 루프의 역할

### 호출 스택(Call Stack)
- 동기 코드 순차 실행

### Web API
- 비동기 작업 처리 (setTimeout 등)

### 태스크 큐(Macrotask Queue)
- setTimeout, setInterval

### 마이크로태스크 큐(Microtask Queue)
- Promise.then, queueMicrotask
- 항상 태스크 큐보다 우선 실행
