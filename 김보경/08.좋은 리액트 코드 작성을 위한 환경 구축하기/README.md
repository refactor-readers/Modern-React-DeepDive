# 08. 좋은 리액트 코드 작성을 위한 환경 구축하기

## 08.1. ESLint를 활용한 정적 코드 분석

> 저희는 최근 신규 구축한 프로젝트들에서는 Biome을 사용하고 있습니다.

### 08.1.1. ESLint 살펴보기

#### ESLint는 어떻게 코드를 분석할까요?

- ESLint는 어떤 방식으로 코드에 대한 정적 분석을 진행할까요?
  1. 자바스크립트 코드를 문자열로 읽습니다.
  2. 자바스크립트 코드를 분석할 수 있는 parser로 코드를 구조화 합니다.
  3. 2번에서 구조화한 트리를 AST(Abstrack Syntax Tree)라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조합니다.
  4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나(report) 수정합니다(fix).
- 여기에서 주목해야 할 부분은 1번 과정에서 읽은 코드를 구조화하는 과정인 2번입니다.
- 자바스크립트를 분석하는 parser에는 여러 가지가 존재하는데, ESLint는 기본값으로 espree를 사용하고 있습니다.
  - 그럼 espree는 어떻게 자바스크립트 파일을 구조화하는 것일까요?
    ```js
    function hello(str) {}
    ```
    - 해당 코드를 espree로 분석하면 다음과 같은 JSON 형태로 구조화된 결과를 얻을 수 있습니다.
    ```json
    {
      "type": "Program",
      "start": 0,
      "end": 22,
      "range": [0, 22],
      "body": [
        {
          "type": "FunctionDeclaration",
          "start": 0,
          "end": 22,
          "range": [0, 22],
          "id": {
            "type": "Identifier",
            "start": 9,
            "end": 14,
            "range": [9, 14],
            "name": "hello"
          },
          "expression": false,
          "generator": false,
          "async": false,
          "params": [
            {
              "type": "Identifier",
              "start": 15,
              "end": 18,
              "range": [15, 18],
              "name": "str"
            }
          ],
          "body": {
            "type": "BlockStatement",
            "start": 20,
            "end": 22,
            "range": [20, 22],
            "body": []
          }
        }
      ],
      "sourceType": "module"
    }
    ```
    - 단순히 한 줄밖에 안되는 코드임에도 불구하고 JSON으로 파싱된 트리에 다양한 정보가 담겨 있음을 확인할 수 있습니다.
      - espree같은 코드 분석 도구는 단순히 변수인지, 함수인지, 함수명은 무엇인지 등 파악만 하는 것이 아니라 코드의 정확한 위치 같은 아주 세세한 정보도 분석하여 알려줍니다.
      - 이러한 자세한 정보가 있어야만 ESLint 혹은 Prettier같은 도구가 코드의 줄바꿈, 들여쓰기 등을 파악할 수 있게 됩니다.
  - ESLint가 espree로 코드를 분석한 결과를 바탕으로, 어떤 코드가 잘못된 코드이며 어떻게 수정해야 할지도 정해야 합니다.
    - 이를 ESLint 규칙(rules)이라고 하며, 특정한 규칙의 모음을 plugins라고 합니다.

#### 완전히 새로운 규칠 만들기: new Date를 금지시키는 규칙

- 자바스크립트에서 `new Date()`는 클라이언트 기기에 종속된 시간값을 가져오므로 기기의 현재 시간을 바꿔버리면 `new Date()`가 반환하는 현재 시간 또한 변경됩니다.
  ```json
  {
    "type": "Program",
    "start": 0,
    "end": 10,
    "range": [0, 10],
    "body": [
      {
        "type": "ExpressionStatement",
        "start": 0,
        "end": 10,
        "range": [0, 10],
        "expression": {
          "type": "NewExpression",
          "start": 0,
          "end": 10,
          "range": [0, 10],
          "callee": {
            "type": "Identifier",
            "start": 4,
            "end": 8,
            "range": [4, 8],
            "name": "Date"
          },
          "arguments": []
        }
      }
    ],
    "sourceType": "module"
  }
  ```
  - `new Date()`를 사용할 때 해당 코드의 사용 여부를 코드 내부에서 파악하기 위해서 espree에서 AST를 어떻게 만드는지 살펴보겠습니다.
    - ExpressionStatement는 해당 코드의 표현식 전체를 나타냅니다.
    - ExpressionStatement.expression은 ExpressionStatement에 어떤 표현이 들어가있는지를 확인합니다. 이것이 ESLint에서 확인하는 하나의 노드 단위입니다.
    - ExpressionStatement.expression.type은 해당 표현이 어떤 타입인지 나타내는데, 여기에서는 생성자(new)를 사용한 NewExpression임을 확인할 수 있습니다.
    - ExpressionStatement.expression.callee는 생성자를 사용한 표현식에서 생성자의 이름을 나타냅니다. 여기에서는 Date임을 확인할 수 있습니다.
    - ExpressionStatement.expression.arguments는 생성자를 표현한 표현식에서 생성자에 전달하는 인수를 나타냅니다. 여기에서는 인수가 없음을 확인할 수 있습니다.
  - AST로 확인한 결과, 금지해야 할 노드가 명확해졌습니다.
    - type은 NewExpression이며, callee, neme이 Date이고, ExpressionStatement.expression.arguments가 빈 배열인 경우에 대해서 ESLint의 crate함수를 통해 규칙을 만들어 보겠습니다.
    ```ts
    /**
     * @type {import('eslint').Rule.RuleModule}
     */
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "disallow use of the new Date()",
          recommended: false,
        },
        fixable: "code",
        schema: [],
        messages: {
          message:
            "new Date()는 클라이언트에서 실행 시 해당 기기의 시간에 의존적이라 정확하지 않습니다. 현재 시간이 필요하다면 ServerDate()를 사용해 주세요.",
        },
      },
      create: function (context) {
        return {
          NewExpression: function (node) {
            if (node.callee.name === "Date" && node.arguments.length === 0) {
              context.report({
                node: node,
                messageId: "message",
                fix: function (fixer) {
                  return fixer.replaceText(node, "ServerDate()");
                },
              });
            }
          },
        };
      },
    };
    ```

## 08.2. 리액트 팀이 권장하는 리액트 테스트 라이브러리

- 테스트란 개발자가 만든 프로그램이 의도한대로 동작하는지 확인하는 일련의 작업을 의미합니다.
- 테스트를 통해 개발자들은 처음에 설계한 대로 프로그램이 동작하는지 확인할 수 있고, 버그를 사전에 방지할 수도 있으며, 이후에 잘못된 작동으로 인해 발생하는 비용도 줄일 수 있게됩니다.
- 코드를 수정하게 되더라도 테스트 과정이 존재한다면 수정한 내용에 대해서도 예외 케이스가 없고 의도한 대로 동작할 수 있는지를 확인할 수 있습니다.
- 이러한 일련의 테스트를 거친 프로그램은 사용자에게 버그가 최소화된 안정적인 서비스를 제공할 수 있는 원동력이 됩니다.
- 프론트엔드와 백엔드는 테스트 하는 방법과 방법론이 사뭇 다릅니다.
  - 백엔드의 테스트는 일반적으로 서버나 데이터베이스에서 원하는 데이터를 올바르게 가져올 수 있는지, 데이터 수정 간 교착 상태나 경쟁 상태가 발생하지 않는지, 데이터 손실은 없는지, 특정 상황에서 장애가 발생하지 않는지 등을 확인하는 과정이 주를 이룹니다.
    - 이러한 백엔드 테스트는 일반적으로 화이트박스 테스트로, 작성한 코드가 의도대로 작동하는지 확인해야 하며, 이는 GUI가 아닌 AUI(Application User Interface: 응용프로그램사용자인터페이스)에서 주로 수행해야 하기 때문에 어느 정도 백엔드에 대한 이해가 있는 사람만 가능합니다.
  - 프론트엔드는 일반적인 사용자와 동일하거나 유사한 환경에서 수행됩니다.
    - 사용자가 프로그램에서 수행할 주요 비즈니스 로직이나 모든 경우의 수를 고려해야 하며, 이 과정에서 사용자는 굳이 프론트엔드 코드를 알 필요는 없습니다.
    - 즉, 블랙박스 형태로 테스트가 이루어지며, 코드와는 상관없이 의도한 대로 동작하는지를 확인하는것에 조금 더 초점이 맞추어져 있습니다.
    - 시나리오가 어느 정도 정해져 있는 백엔드와는 다르게, 프론트엔드는 사용자에게 완전히 노출된 영역이므로 어떻게 작동할지 최대한 예측해서 확인해야 합니다. 사용자는 개발자의 의도대로만 사용하지 않기 때문입니다.

### 08.2.5. 테스트를 작성하기에 앞서 고려해야할 점

- 테스트 커버리지가 만능은 아닙니다. 테스트 커비리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아닙니다. 그로므로 테스트 커버리지를 맹신헤서는 안됩니다.
  - 또 한가지는 테스트 커버리지를 100%까지 끌어올릴 수 있는 상황은 생각보다 드물다는 것입니다.
  - 이른바 TDD라고 하는 개발방법론을 차용해서 테스트를 우선시하더라도 서버 코드와는 다르게 프론트엔드 코드는 사용자의 입력이 매우 자유롭기 때문에 이러한 모든 상황을 커버하여 테스트를 작성하기란 불가능합니다.
- 추가적으로 실무에서는 테스트코드를 작성하고 운영할 만큼 여유로운 상황이 얼마 없습니다. 떄로는 테스트를 QA에 의존하여 개발을 빠르게 진행해야 할 수도 있으며, 이후에 또 개발해야 할 기능이 산적해 있을 수도 있습니다.
- 따라서 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것 입니다.
  - 예를 들어, 전자상거래 애플리케이션을 만든다고 가정해 보았을 때, 애플리케이션의 모든 부분이 우선순위를 가릴 수 없이 중요하겠지만 가장 신경 써야 할 것은 바로 결제 기능입니다.
  - 테스트하기로 정한 기능과 관련된 코드를 파악한 후 해당 코드들이 어떻게 순차적으로 실행되는지 확인한 다음, 그 순차적인 프로세스에 맞추어 테스트 코드를 작성하면 됩니다.
  - 이 테스트가 통과해야 할 테스트 코드는 반드시 사용자의 작업과 최대한 유사하게 작성되어야 합니다.
  - 예를 들어, 결제를 위해 사용자가 입력하는 절차, 장바구니, 주소 입력, 결제까지의 과정을 모두 사용자와 최대한 비슷한 입장에서 테스트를 작성하는 것이 필요합니다.
- 이처럼 가장 핵심이 되는 부분부터 먼저 테스트 코드를 하나씩 작성해 나가는 것이 중요합니다.
- 테스트 코드는 소프트웨어의 코드를 100% 커버하기 위해, 혹은 테스트 코드가 모두 그린 사인을 보기 위해 작성하는 것이 아닙니다.
- **테스트코드는 개발자가 단순 코드 작성만으로는 쉽게 이룰 수 없는 목표인 소프트웨어 품질에 대한 확인을 얻기 위해 작성하는 것 입니다.**

### 08.2.6. 그 밖에 해볼 만한 여러 가지 테스트

- 유닛 테스트: 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도한 대로 정확히 작동하는지 검증하는 테스트
- 통합 테스트: 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드 테스트: E2E테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용하여 애플리케이션의 전체적인 기능을 확인하는 테스트

### 08.2.7. 정리

- 테스트가 이뤄야 할 궁극적인 목표는 **애플리케이션이 비즈니스 요구사항을 충족하는지 확인**하는 것 한가지뿐 입니다.
- 조금씩, 그러나 핵심적인 부분부터 테스트 코드를 작성하다 보면 소프트웨어의 품질에 확신을 갖게 될 것입니다.
