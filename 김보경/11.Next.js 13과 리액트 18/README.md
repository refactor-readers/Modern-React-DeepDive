# Next.js 13과 리액트 18

## 11.1 app 디렉터리의 등장

- 이전 버전까지 Next.js의 아쉬운 점으로 평가받던 것 중 하나는 바로 레이아웃의 존재입니다.
- 공통 헤더와 공통 사이드바가 거의 대부분이 페이지에 필요한 웹사이트를 개발한다고 가정해보겠습니다.

### 11.1.1. 라우팅

#### layout.js

- Next.js 13부터는 app 디렉처리 내부의 폴더명이 라우팅되며, 이 폴더에 포함될 수 있는 파일명은 몇 가지로 제한되어있습니다. 그중 하나가 layout.js 입니다.
- 파일 이름에서 알 수 있는 것처럼 페이지의 기본적인 레이아웃을 구성하는 요소입니다.
- 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미치게 됩니다.

> 나머지 내용은 공식문서와 내용이 유사하여 생략헤보겠습니다.

## 11.2 리액트 서버 컴포넌트

- 리액트 18에서 새로 도입된 리액트 서버 컴포넌트는 서버 사이드 렌더링과 완전히 다른 개념입니다.
- 두 용어 모두 "서버" 라는 단어가 포함되어있어 혼동의 여지가 있지만 "서버"라는 단어가 있다는 점, 그리고 "서버"에서 무언가 작업을 수행한다는 점을 제외하면 완전히 다른 개념으로 보는 것이 옳습니다.

### 11.2.1. 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 리액트 그리고 Next.js에서 제공하는 서버 사이드 렌더링은 얼핏보면 더할 나위 없는 구조를 갖고있는것 처럼 보이지만 몇 가지 명백한 한계점이 존재합니다.
  - 자바스크립트 번들 사이즈가 0인 컴포넌트를 만들 수 없습니다
    - 게시판 등 사용자가 작성한 HTML에 위험한 태그를 제거하기 위해 사용되는 유명한 라이브러리로 `sanitize-html`이 있습니다.
      해당 `sanitize-html` 라이브러리를 리액트 컴포넌트에서 사용한다고 가정해보겠습니다.
      - `sanitize-html`를 사용하는 컴포넌트에서는 63.3KB에 달하는 모듈을 필요로 하며, 더욱이 이는 클라이언트인 브라우저에서 해당 라이브러리를 다운로드해야 할 뿐만 아니라 실행까지 거쳐야 합니다.
    - 이처럼 어느 정도 규모있는 웹 애플리케이션을 작성하다 보면 브라우저 환경에서 타사 라이브러리의 이용은 피할 수 없게 됩니다.
    - **그리고 이는 그만큼 사용자 기기의 부담으로 고스란히 자리 잡게됩니다.**
    - 만약 이 컴포넌트를 서버에서만 렌더링하고 클라이언트는 결과만 받는다면 어떻게될까요?
      - `sanitize-html`은 서버만 가지고 있고, 서버에서는 해당 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물만 클라이언트에 제공하게 된다면 클라이언트는 더 이상 무거운 `sanitize-html` 라이브러리를 다운로드하여 실행하지 않고도 사용자에게 보여주고 싶은 컴포넌트를 렌더링할 수 있게 될 것입니다.
  - 백엔드 리소스에 대한 직접적인 접근이 불가능합니다.
    - 리액트를 사용하는 클라이언트에서 백엔드 데이터에 접근하려면 REST API와 같은 방법을 사용하는 것이 일반적입니다.
    - 이 방법은 편리하지만 백엔드에서 항상 클라이언트에서 데이터를 접근하기 위한 방법을 마련해야 한다는 불편함이 존재합니다.
    - 만약 클라이언트에서 직접 백엔드에 접근하여 원하는 데이터를 가져올 수 있다면 어떨까요?
      - 데이터베이스에 직접 엑세스하거나, 혹은 백엔드의 파일 시스템에 직접 접근하는 등 클라이언트에 데이터를 제공하기 위한 수고로움이 줄어들 것입니다.
      - 또한 성능 관점에서 볼 때도 마찬가지로 백엔드에 접근할 수 있는 단계가 하나 줄어든 셈이므로 확실히 더 이점을 가지고 있다고 볼 수 있습니다.
  - 자동 코드 분할(code split)이 불가능합니다.
    - 코드 분할이란 하나의 거대한 코드 번들 대신, 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연 로딩함으로서 앱을 초기화하는 속도를 높여주는 기법을 이야기합니다.
    - 일반적으로 리액트에서는 lazy를 사용해 구현해왔습니다.
  - 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵습니다.
    - 하나의 요청으로 컴포넌트가 렌더링되고, 또 그 컴포넌트의 렌더링 결과로 또 다른 컴포넌트들을 렌더링하는 시나리오를 상상해보겠습니다.
      - 이 시나리오에서는 최소 컴포넌트의 요청과 렌더링이 끝나기 전까지는 하위 컴포넌트의 요청과 렌더링이 끝나지 않는다는 큰 단점이 있습니다.
      - 또한 그만큼 서버에 요청하는 횟수도 늘어나게 됩니다.
      - 그리고 부모 컴포넌트의 요청과 렌더링이 결정되기 전까지, 그 부모 컴포넌트의 결과물에 의존하는 하위 컴포넌트들의 서버 요청이 지연되고 아직 렌더링될 준비가 되지 않았음을 나타내는 불필요한 렌더링까지 발생합니다.
    - 그렇다면 만약 이러한 직업을 서버에서 모두 수행하면 어떨까요?
      - 데이터를 불러오고 컴포넌트를 렌더링하는 것이 모두 서버에서 이루어지므로 클라이언트에서 서버로 요청함으로써 발생하는 지연을 줄일 수 있고, 또한 클라이언트에서는 반복적으로 요청을 수행할 필요도 없어집니다.
      - 서버에서는 필요에 따라 백엔드 데이터에 접근하거나 지속적으로 데이터를 불러옮으로써 클라이언트에서보다 더 효율적으로 컴포넌트를 렌더링할 수 있게 됩니다.
  - 추상화에 드는 비용이 증가합니다.
    - 리액트는 템플릿 언어로 설계되지 않았습니다.
      - 일반적으로 웹 개발에서 템플릿 언어란 HTML에 특정 언어의 문법을 집어넣어 사용할 수 있는 것을 의미합니다.
      - 템플릿 언어는 HTML에서 할 수 없는 for문이나 if문 등을 처리할 수 있지만 그 밖의 복잡한 추상화나 함수 사용은 어렵습니다.
    - 모두가 아는 것처럼, 리액트는 자바스크립트를 기반으로 함수나 클래스를 사용하여 다양한 작업을 수행할 수 있게끔 제공합니다.
    - 이는 개발자에게 자유를 주지만 문제는 이러한 추상화가 복잡해질수록 코드의 양은 많아지고, 런타임 시에는 오버헤드가 발생한다는 점입니다.
    - 만약 이렇게 복잡한 추상화에 따른 결과물을 연산하는 작업을 서버에서 수행하면 어떨까요?
      - 컴포넌트가 여러 개가 중첩되고 합성되어 복잡해 보일 수 있지만 서버에서 클라이언트로 전송되는 내용을 서버에서 미리 다 계산해서 내려준다면 여러 가지 장점이 존재합니다.
        - 클라이언트에서는 복잡한 작업을 하지 않아도 되므로 속도가 빨라질 것이고, 서버에서 클라이언트에서 전송되는 결과물 또한 단순하고 가벼워질 것입니다.
        - 코드 추상화에 따른 비용은 서버에서만 지불하면 됩니다.
- 이러한 서버 사이드 렌더링의 한계점을 쭉 살펴본다면 모든 문제는 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제라는 것을 알 수 있습니다.
  - 물론 과거 레거시 웹 애플리케이션처럼 정적인 방식의 서버 사이드 렌더링 방식을 도입하면 이러한 문제들을 일부 해결할 수 있지만 리액트처럼 브라우저에서 고객에게 다양한 경험을 안겨주기는 어렵습니다.
    - 성능을 위해 클라이언트의 역할을 일부 희생할것인가
    - 혹은 사용자에게 다양한 경험을 안겨주기 위해 일부 성능을 희생하더라도 클라이언트에서 다양한 작업을 처리할 것인가
  - 결국 SSR, CSR은 모두 이 문제를 해결하기에는 조금의 아쉬움이 존재합니다.
- **SSR은 정적 콘텐츠를 빠르게 제공**하고, 서버에 있는 데이터를 손쉽게 제공할 수 있는 반면 사용자의 인터렉션에 따른 다양한 사용자 경험을 제공하긴 어렵습니다.
- CSR은 사용자의 인터렉션에 따라 정말 다양한 것들을 제공할 수 있지만 서버에 비해 느리고 데이터를 가져오는 것도 어렵습니다.
- 이러한 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트 입니다.

### 11.2.2. 서버 컴포넌트란?

- 서버 컴포넌트란 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링 할 수 있는 기법을 의미합니다.
  - 서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행됩니다.
  - 즉, 일부 컴포넌트는 클라이언트에서, 일부 컴포넌트는 서버에서 렌더링되는 것입니다.
- 한 가지 명심해야 하는 사실은 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다는 것 입니다.
  - 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없기 때문에(서버 환경이 브라우저에는 존재하지 않으므로) 컴포넌트를 호출할 수 없습니다.
- **그렇다면 과연 어떻게 리액트 트리 내부의 컴포넌트를 서버 컴포넌트와 클라이언트 컴포넌트 각각을 만들어서 관리할 수 있는 것일까요?**
  ![예시1](./서버컴포넌트와%20클라이언트컴포넌트의%20트리구조.png)
- 리액트 컴포넌트 트리를 간단히 도식화한 예시입니다.

  - 서버 컴포넌트의 이론에 따르면 모든 컴포넌트는 서버 컴포넌트가 될 수도 있고, 클라이언트 컴포넌트가 될 수도 있습니다.
  - 따라서 컴포넌트 트리에서 위와 같이 클라이언트 및 서버 컴포넌트가 혼재된 상황은 자연스러울 것입니다.
  - 어떻게 이런 구조가 가능한 것일까요? 그 비밀은 흔히 `children`으로 자주 사용되는 `ReactNode`에 달려있습니다.

    ```tsx
    "use client";

    // ClientComponent.jsx
    import ServerComponent from "./ServerComponent.server";

    export default function ClientComponent({ children }) {
      return (
        <div>
          <h1>클라이언트 컴포넌트</h1>
          {children}
        </div>
      );
    }

    // ServerComponent.jsx
    export default function ServerComponent() {
      return <span>서버 컴포넌트</span>;
    }

    // ParentServerComponent.jsx
    // 이 컴포넌트는 서버 컴포넌트일 수도, 클라이언트 컴포넌트일 수도 있다.
    // 따라서 둘 군데 모두에서 사용할 수 있다.
    import ClientComponent from "./ClientComponent";
    import ServerComponent from "./ServerComponent";

    export default function ParentServerComponent() {
      return (
        <ClientComponent>
          <ServerComponent />
        </ClientComponent>
      );
    }
    ```

    - 위 코드는 리액트 서버 컴포넌트를 기반으로 리액트 컴포넌트 트리를 설계할 때 어떠한 제한이 생기는지를 나타냅니다.
    - 한 가지 눈에 띄는 것은 서버 컴포넌트와 클라이언트 컴포넌트가 있으며 동시에 두 군데에서 모두 사용할 수 있는 공용 컴포넌트가 있다는 것입니다.
    - 세 컴포넌트의 제약사항에 대해 각각 알아보겠습니다.
      - 서버 컴포넌트
        - 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없습니다. 따라서 리액트에서 상태를 가질 수 있는 useState, useReducer 등의 훅을 사용할 수 없습니다.
        - 렌더링 생명주기도 사용할 수 없습니다. 한번 렌더링되면 그걸로 끝입니다. 따라서 useEffect, useLayoutEffect를 사용할 수 없습니다.
        - 앞의 두 가지 제약사항으로 인해 effect나 state에 의존하는 사용자 정의 훅 또한 사용할 수 없습니다. 다만 effect나 state에 의존하지 않고 서버에서 제공할 수 있는 기능만 사용하는 훅이라면 충분히 사용 가능합니다.
        - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰거나 windiw, document 등에 접근할 수 없습니다.
        - 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await 으로 접근할 수 있습니다. 컴포넌트 자체가 async한 것이 가능합니다.
        - 다른 서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나, 혹은 클라이언트 컴포넌트를 렌더링할 수 있습니다.
      - 클라이언트 컴포넌트
        - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없습니다.
        - 그러나 앞의 코드에서 본 것처럼 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능합니다.
          - 그 이유는 클라이언트 입장에서 보았을 때 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고, 클라이언트 컴포넌트는 이미 서버에서 만들어진 그 트리를 삽입해서 보여주기만 하기 때문입니다.
          - 따라서 서버 컴포넌트와 클라이언트 컴포넌트를 중첩해서 갖는 위 이미지와 같은 구조로 설계하는 것이 가능합니다.
        - 이 두가지 예외 사항을 제외하면 일반적으로 우리가 알고 있는 리액트 컴포넌트와 같습니다. state와 effect를 사용할 수 있으며, 브라우저 API도 사용할 수 있습니다.
      - 공용 컴포넌트 (shared component)
        - 이 컴포넌트는 서버와 클라이언트 모두에서 사용할 수 있습니다.
        - 공통으로 사용할 수 있는 만큼, 당연히 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 됩니다.

- 그렇다면 리액트는 어떻게 서버 컴포넌트인지, 클라이언트 컴포넌트인지, 공용 컴포넌트인지를 판단할까요?
  - 기본적으로 알아두어야 하는 사실은 리액트는 모든 것을 다 공용 컴포넌트로 판단한다는 것입니다.
  - 즉, 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류합니다.
    - 대신, 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 파일의 맨 첫줄에 "use client"라고 작성해 두면 됩니다.
    - 그리고 앞서 언급한 제약 중 하나인 클라이언트 컴포넌트가 서버 컴포넌트를 import 하는 상황에서는 빌드 시 에러가 발생합니다.

### 11.2.3. 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링과 서버 컴포넌트는 완전히 다른 개념으로 보아야 합니다.
  - 먼저 서버 사이드 렌더링은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 수 그 결과를 클라이언트에 내려주게 됩니다.
  - 그리고 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행합니다.
  - **서버사이드 렌더링의 목적은 초기에 인터렉션은 불가능하지만 정적인 HTML을 빠르게 내려주는것에 초점을 두고 있습니다.**
  - 따라서 여전히 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고, 파싱하고, 실행하는데 비용이 듭니다.
- 따라서 이후에는 서버 사이드 렌더링과 서버 컴포넌트를 모두 채택하는 것도 가능해질 것입니다.
  - 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 빠르게 전달받을 수 있습니다.
  - 이 두 가지 방법을 모두 결합하면 클라이언트 및 서버 컴포넌트를 모두 빠르게 보여줄 수 있고, 동시에 클라이언트에서 내려받아야 하는 자바스크립트의 양도 줄어들어 브라우저의 부담을 덜 수도 있습니다.
- 결론적으로 둘은 대체제가 아닌 상호보완하는 개념으로 보야아 할 것입니다.
- 리액트 팀에서도 미래에는 두 가지 기법이 모두 쓰일 수 있는 가능성을 암시하고 있습니다.
  > 리액트 19에서의 업데이트 내용을 살펴보면 서버컴포넌트 내용이 다수 있었던 것 같은데 다시 찾아보는게 좋을거같네요!

### 11.2.4. 서버 컴포넌트는 어떻게 작동하는가?

```ts
app.get(
  "/",
  handleErrors(async function (_req, res) {
    await waitForWebpack();
    const html = readFileSync(
      path.resolve(__dirname, "../build/index.html"),
      "utf8"
    );
    // Note: this is sending an empty HTML shell, like a client-side-only app.
    // However, the intended solution (which isn't built out yet) is to read
    // from the Server endpoint and turn its response into an HTML stream.
    res.send(html);
  })
);
```

- `waitForWebpack`은 단순히 개발 환경에서 웹팩이 빌드 경로에 index.html을 만들 때까지 기다리는 코드일 뿐이라는 것을 염두해 둔다면 사용자가 최초에 들어왔을 때 수행하는 작업은 오로지 index.html을 제공하는 것 뿐입니다.
  1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작됩니다.
  - 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트 입니다.
  2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화합니다.
  - 이때 서버에서 렌더링 할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타냅니다.
  - 브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행합니다.
  3. 브라우저가 리액트 컴포넌트 트리를 구성합니다.
  - 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성하여 컴포넌트를 만들어 나가게 됩니다.
  - 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행할 것이고, 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 그대로 만들 것입니다.
  - 그리고 최종적으로 이 트리를 렌더링하여 브라우저의 DOM에 커밋하게 됩니다.
- 지금까지의 내용을 바탕으로 리액트 서버 컴포넌트의 동작 방식의 특별한 점을 몇 가지 살펴보겠습니다.
  - 먼저 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빠르게 사용자에게 결과물을 보여줄 수 있다는 장점이 있습니다.
  - 또한 컴포넌트들이 하나의 번들러 작업에 포함되어 있지 않고 각 컴포넌트별로 번들링이 별개로 되어있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능해졌습니다.
  - 마지막으로, 서버 사이드 렌더링과는 다르게 결과물이 HTML이 아닌 JSON 형태로 보내진 것 또한 주목해 볼 만합니다.
    - 클라이언트의 최종 목표는 리액트 컴포넌트 트리를 서버 컴포넌트와 클라이언트 컴포넌트의 두 가지로 조화롭게 구성하는 것으로, 이는 단순히 HTML을 그리는 작업 이상의 일을 필요로 합니다.
    - 따라서 HMTL 대신 단순한 리액트 컴포넌트 구조를 JSON으로 받아서 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와줍니다.

## 11.5. 서버 액션

### 11.5.1 form의 action

- form은 HTML에서 양식을 보낼 때 사용하는 태그로, action props를 추가해서 이 양식 데이터를 처리할 URI를 넘겨줄 수 있습니다.

```tsx
export default function Page() {
  async function handleSubmit() {
    "use server";

    console.log(
      "해당 작업은 서버에서 수행합니다. 따라서 CORS 이슈가 없습니다."
    );

    const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "post",
      body: JSON.stringify({
        title: "foo",
        body: "bar",
        userId: 1,
      }),
      headers: {
        "Content-type": "application/json; charset=UTF-8",
      },
    });

    const result = await response.json();

    console.log(result);
  }

  return (
    <form action={handleSubmit}>
      <button type="submit">form 요청 보내보기</button>
    </form>
  );
}
```

- "use server"로 선언되어 있는 내용을 빌드 시점에 미리 클라이언트에서 분리시키고 서버로 옮김으로써 클라이언트 번들링 결과물에는 포한되지 않고 서버에서만 실행되는 서버 액션을 만든 것을 확인할 수 있습니다.
