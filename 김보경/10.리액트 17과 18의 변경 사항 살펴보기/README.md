# 10. 리액트 17과 18의 변경 사항 살펴보기

## 10.1. 리액트 17 버전 살펴보기

- 리액트 17 버전은 16 버전과는 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다는 점을 가장 큰 특징으로 꼽을 수 있습니다.

### 10.1.1. 리액트의 점진적인 업그레이드

- 리액트 16에서 17로의 업데이트는 기존 버전인 16에서 더 이상 호환되지 않는 API가 있거나 새로운 리액트 17을 사용하는 데 있어 이전과 작동 방식이 달라질 수 있기 때문에 단행된 주 버전 업데이트입니다.
  - 반면 수 버전 업데이트인 16.7에서 16.8로의 버전업은 신규 기능 추가(리액트 훅)로 인해 발생한 것이다.
- 즉, 새로운 주 버전이 릴리즈되면 이전 버전에서의 API 제공을 완전히 중단해버리고, 전체 애플리케이션을 새롭게 업그레이드 하기를 요구하고 있습니다.
- 그러나 이제 리액트 17 버전부터는 점진적인 업그레이드가 가능해졌습니다.
  - 전체 애플리케이션 트리는 리액트 17을 사용하지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다는 것 입니다.
  - 관리지점도 많이지고 이상적인 방법이 아닐 수는 있지만 리액트 버전을 올리기에는 부담이되는 거대한 애플리케이션의 경우에는 충분히 고려해 볼 만한 선택지가 될 수 있습니다.

### 10.1.2. 이벤트 위임 방식의 변경

- 이벤트 위임 방식의 변화를 이해하려면 먼저 리액트에서 이벤트가 어떻게 추가되는지를 이해해야 합니다.
  - "버튼" 컴포넌트를 사용해서 일반적으로 리액트 애플리케이션에서 DOM에 이벤트를 추가하는 방식으로 onclick 이벤트를 추가할 수 있습니다.
  - 반면 "그냥 버튼"의 이벤트로 직접 DOM을 참조해서 가져온 다음, DOM의 onclick에 직접 함수를 추가하는 고전적인 이벤트 핸들러 추가 방식을 사용할 수 있습니다.
- 이제 이 두가지 방법이 실제 웹이서 어떻게 다른지 살펴보겠습니다.
  - "그냥 버튼"은 해당 버튼의 이벤트 리스너에 click으로 추가됩니다. 해당 핸들러를 클릭해보면 앞서 작성한 click함수를 가리키고 있습니다.
  - 리액트로 부착한 이벤트의 경우에는 `<button>`의 onClick 이벤트에 noop이라는 핸들러가 추가되어 있는 것을 볼 수 있습니다.
    - noop은 문자 그대로 no operation 아무런 일도 하지 않는것을 확인 가능하지만 실제로 버튼은 의도한대로 동작을 수행하게 됩니다.
    - 왜 그런걸까요?
      - 리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부착하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착합니다.
      - 이를 이벤트 위임이라고 합니다. 이벤트 위힘을 이해하려면 이벤트가 어떤 단계로 구성되어 있는지를 먼저 알아야 합니다.
        1. 캡처: 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미합니다.
        2. 타깃: 이벤트 핸들러가 타깃 노드에 도달하는 단계입니다. 이 단계에서 이벤트가 호출됩니다.
        3. 버블링: 이벤트가 발생한 요소에서부터 시작하여 최상위 요소까지 다시 올라갑니다.
      - 이벤트 위임이란 이러한 이벤트 단계의 원리를 활용하여 이벤트를 상위 컴포넌트에만 붙이는 것을 의미합니다.
    - 이처럼 리액트에서는 이벤트 위임을 사용해서 이밴트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 조금 더 효율적으로 관리합니다.
- 이러한 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행되고 있었습니다. 하지만 리액트 17 부터는 이러한 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 변경되었습니다.
  - 왜 그런걸까요?
    - 앞서 이야기했던 점진적인 업그레이드 지원, 그리고 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재되어 있는 경우 혼란을 방지하기 위해서 입니다.
    - 만약 17버전 이전 리액트가 한 서비스 안에 어러 버전이 공존한다고 가정한다면 이벤트 위임 원리에 따라 모든 이벤트는 document에 부착됩니다.
    - 문제는 리액트까리만 발생하는 것이 아닌 jQuery와 같은 다른 라이브러리와 리액트 16등이 혼재되어 있는 상황인 경우에도 이와 동일한 문제가 발생할 수 있다는 것 입니다.

### 10.1.4. 그 밖의 주요 변경사항

#### 이벤트 풀링 제거

#### useEffect 클린업 함수의 비동기 실행

#### 컴포넌트의 undefined 반환에 대한 일관적인 처리

## 10.2. 리액트 18 버전 살펴보기

### 10.2.1. 새로 추가된 훅 살펴보기

#### useId

- 컴포넌트별로 유니크한 값을 생성하는 새로운 훅입니다.
- 사실 컴포넌트 내부에사 사용할 수 있는 유니크한 값을 생성하는 것은 생각보다 쉽지 않은 일입니다.
- 하나의 컴포넌트가 여러 군데에서 재사용되는 경우도 고려해야 하며 다른 컴포넌트 트리에서 사용하는 값과 겹치지 않도록 처리해야 하고, 하이드레이션 과정에서 서버와 클라이언트가 동일한 값을 가져야 에러가 발생하지 않습니다.
- useId를 사용하면 동일한 컴포넌트임에도 서로 인스턴스가 다르면 다른 랜덤한 값을 만들어내며, 이 값들이 모두 유니크한 것을 확인할 수 있습니다.
- 또한 하이드레이션 이슈도 발생하지 않으며 내부 소스코드를 확인해보면 useId가 생성하는 값은 `:`로 감싸져 있는데, 이는 CSS 선택자나 querySelector에서 작동하지 않도록 하기 위한 의도적인 결과입니다.

#### useTransition

- useTransition은 UI변경을 가로막지 않고 상태를 업데이트 할 수 있는 리액트 훅입니다.
- 해당 훅을 활용해서 상태 업데이트를 긴급하지 않은 것으로 간주하여 무거운 렌더링 작업을 조금 미룰 수 있으며, 사용자에게 조금 더 나은 UX를 제공할 수 있게 됩니다.
- useTransition은 리액트 18의 변경 사항의 핵심 중 하나인 **동시성(concurrency)**을 다룰 수 있는 새로운 훅입니다.
  - 과거 리액트의 모든 렌더링은 동기적으로 동작하여 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 useTransition과 같은 동시성을 지원하는 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 현재 진행중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 됩니다.
- useTransition을 사용할 때 주의할 점을 몇 가지 살펴보겠습니다.
  - startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있습니다. 민약 props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶다면 뒤이어 설명한 useDefferedValue를 사용하면 됩니다.
  - startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있습니다. 예를 들어, 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않습니다.
  - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 합니다. 만약 setTimeout과 같은 비공기 함수를 주입하면 재대로 동작하지 않게 됩니다. 이는 startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나기 때문입니다.

#### useDeferredValue

- useDeferredValue는 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅입니다.
- 일반적으로 개발자들 사이에서 널리 사용되고 있는, 특정 시간동안 발생하는 이벤트를 하나로 인식하여 한 번만 실행하게 해주는 디바운스와 유사하지만 디바운스 대비 useDeferredValue만이 가진 장점이 몇 가지 있습니다.
  - 먼저 디바운스는 고정된 지연 시간을 필요로 하지만 useDeferredValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 useDeferredValue로 지연된 렌더링을 수행합니다. 그러무로 이 지연된 렌더링은 중단할 수도 있으며, 사용자의 인터렉션도 차단하지 않습니다.
- useTransition과는 어떤 차이점이 있을까요?
  - useTransition은 state값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state값 자체만을 감싸서 사용하는 것을 볼 수 있습니다.
  - 방식에만 차이가 있을 뿐, 지연된 렌더링을 한다는 점에서는 모두 동일한 역할을 수행합니다. 따라서 두 가지를 모두 동시에 사용할 필요는 없으며, 상황에 맞게 사용하시면 됩니다.
    - 만약 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트할 수 있는 코드에 접근할 수 있다면 useTransition을 사용하는 것이 좋습니다.
    - 그러나 컴포넌트의 props와 같이 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 상황이라면 useDeferredValue를 사용하는 것이 타당합니다.

#### useSyncExternalStore

- useSyncExternalStore는 일반적인 애플리케이션 코드를 작성할 때는 사용할 일이 별로 없는 훅입니다.
- 이 훅의 기원을 알기 위해서는 리액트 17까지 존재했던 useSubscription에 대해 알아야 합니다.
  - 간단히 요약하면 useSubscription의 구현이 리액트 18에 이르러서 useSyncExternalStore로 대체된 것을 확인할 수 있습니다.
- 이 훅이 어떤 일을 하는지 살펴보기에 앞서 테어링 현상에 대해 알아보겠습니다.
  - tearing은 영어로 찢어진다 라는 뜻으로, 리액트에서는 하나의 state값이 있음에도 서로 다른 값(보통 state나 props의 이전과 이후)을 기준으로 렌더링되는 현상을 이야기합니다.
  - 리액트 17에서는 사실 이러한 현상이 일어날 여지가 없었습니다.
  - 그러나 리액트 18에서는 앞서 useTransition, useDeferredValue의 훅처럼 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 동시성 이슈가 발생할 수 있습니다.
  - 과거 리액트에서는 중간에 데이터 업데이트가 일어나는 것과 상관없이 동기적으로 렌더링이 한 번에 발생해서 이러한 문제가 없었습니다.
- 리액트에서 관리하는 state라면 useTransition, useDeferredValue와 같이 내부적으로 이러한 문제를 해결하기 위한 처리를 해두었지만 리액트에서 관리할 수 없는 외부 데이터 소스에서라면 문제가 달라집니다.
  - 여기에서 말하는 리액트가 관리할 수 없는 외부 데이터 소스란 리액트의 클로저 범위 밖에 있는, 관리 범위 밖에 있는 값들을 의미합니다.
  - 글로벌 변수, document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리 등이 모두 여기에 해당합니다.
  - 즉 useState, useReducer가 아닌 모든 것들이 바로 외부 데이터 소스입니다.
  - 이러한 외부 데이터 소스에 리액트에서 추구하는 동시성 처리가 되어있지 않다면 테어링 현상이 발생할 수 있고, 이 문제를 해결하기 위한 훅이 바로 useSyncExternalStore 입니다.

#### useInsertionEffect

- 앞서 useSyncExternalStore가 상태관리 라이브러리를 위한 훅이라면 useInsertionEffect는 CSS-in-js 라이브러리를 위한 훅입니다.
- 리액트 17과 styled-components 에서는 클라이언트 렌더링 시에 CSS의 추가 및 수정 등 브라우저에서 렌더링하는 작업을 다시 계산하지 않도록 서버사이드에서 스타일 코드를 삽입해주었습니다.
- 이런 작업을 훅으로 처리할 수 있도록 도와주는 훅이 useInsertionEffect입니다.
- useInsertionEffect의 기본적인 훅 구조는 useEffect와 동일합니다.
  - 다만 useEffect와 다른 차이점은 바로 실행 시점인데, useInsertionEffect는 DOM이 실제로 반영되기 전에 동기적으로 실행됩니다.
  - 이 훅 내부에 스타일을 삽입하는 코드를 집어넣음으로써 브라우저가 레이아웃을 계산하기 전에 실행될 수 있게끔 해서 좀 더 자연스러운 스타일 삽입이 가능해집니다.

### 10.2.2. react-dom/client

- 클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경되었습니다.

### 10.2.3. react-dom/server
